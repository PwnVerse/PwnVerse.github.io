<!doctype html><html class="dark light"><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Kqueue - InCTF Internationals 2021
        
    </title><meta content="Kqueue - InCTF Internationals 2021" property=og:title><link href=https://pwnverse.github.io/fonts.css rel=stylesheet><script>(function(){var a=document.createElement('script');a.setAttribute('src','/js/imamu.js');a.setAttribute('data-website-id','74344cd8-1e87-4c38-8acd-f96049b8f07e');a.setAttribute('data-host-url','https:&#x2F;&#x2F;analytics.eu.umami.is');document.body.appendChild(a)})()</script><script async data-host-url=https://analytics.eu.umami.is data-website-id=74344cd8-1e87-4c38-8acd-f96049b8f07e src=/js/imamu.js></script><script async data-goatcounter=https://Cyb0rG.goatcounter.com/count src=https://pwnverse.github.io/js/count.js></script><noscript><img src="https://Cyb0rG.goatcounter.com//count?p=/posts/kqueue/&t=Kqueue - InCTF Internationals 2021"></noscript><link title="Cyb0rG's Home" href=https://pwnverse.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://pwnverse.github.io/theme/light.css rel=stylesheet><link href=https://pwnverse.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><link href=https://pwnverse.github.io/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://pwnverse.github.io>Cyb0rG's Home</a><div class=socials><a class=social href=https://twitter.com/_Cyb0rG rel=me> <img alt=twitter src=/social_icons/twitter.svg> </a><a class=social href=https://github.com/PwnVerse/ rel=me> <img alt=github src=/social_icons/github.svg> </a></div></div><nav><a href=/posts style=margin-left:.7em>/posts</a><a href=/projects style=margin-left:.7em>/projects</a><a href=/about style=margin-left:.7em>/about</a> | <a href=javascript:void(0) id=dark-mode-toggle onclick=toggleTheme()> <img id=sun-icon src=/feather/sun.svg style=filter:invert(1)> <img id=moon-icon src=/feather/moon.svg> </a><script src=https://pwnverse.github.io/js/themetoggle.js></script></nav></header><main><article><div class=title><div class=page-header>Kqueue - InCTF Internationals 2021<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2021-08-17</time></div></div><section class=body><p><strong>tl;dr</strong><ul><li>Use the integer overflow to trigger a kernel heap overflow.<li>Use the heap overflow to overwrite <code>tty</code> structure function pointers to get code execution.</ul><p><strong>Challenge Points:</strong> 986 <strong>No of Solves:</strong> 7 <strong>Challenge Author:</strong> <a href=https://twitter.com/_Cyb0rG>Cyb0rG</a><h2 id=challenge-description>Challenge description</h2><p><code>A long queue awaits you in ring0</code><p>To start with , the challenge handout folder comes with <code>bzImage</code>, <code>rootfs.cpio</code>, <code>run.sh</code> and source code files.<p>We immediately see that <code>smep</code> and <code>smap</code> are disabled in the <code>run.sh</code>.<h2 id=analysis>Analysis</h2><p>The module implements <code>create</code>, <code>delete</code> , <code>edit</code> and <code>save</code> functionalities.<p>Before heading to the functionalities, it is better we refer to the important structures being used for various operations.<h3 id=queue-structure>Queue structure</h3><pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=color:#ff7733>typedef struct</span><span>{
</span><span>    </span><span style=font-style:italic;color:#39bae6>uint16_t</span><span> data_size</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=font-style:italic;color:#39bae6>uint64_t</span><span> queue_size</span><span style=color:#bfbab0cc>; </span><span style=font-style:italic;color:#5c6773>/* This needs to handle larger numbers */
</span><span>    </span><span style=font-style:italic;color:#39bae6>uint32_t</span><span> max_entries</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=font-style:italic;color:#39bae6>uint16_t</span><span> idx</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>char</span><span style=color:#f29668>*</span><span> data</span><span style=color:#bfbab0cc>;
</span><span>}</span><span style=color:#59c2ff>queue</span><span style=color:#bfbab0cc>;
</span></code></pre><h3 id=structure-of-each-entry-in-queue>Structure of each entry in queue</h3><pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=color:#ff7733>struct </span><span style=color:#59c2ff>queue_entry</span><span>{
</span><span>    </span><span style=font-style:italic;color:#39bae6>uint16_t</span><span> idx</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>char </span><span style=color:#f29668>*</span><span>data</span><span style=color:#bfbab0cc>;
</span><span>    queue_entry </span><span style=color:#f29668>*</span><span>next</span><span style=color:#bfbab0cc>;
</span><span>}</span><span style=color:#bfbab0cc>;
</span></code></pre><h3 id=structure-of-request-from-userspace>Structure of request from userspace</h3><pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=color:#ff7733>typedef struct</span><span>{
</span><span>    </span><span style=font-style:italic;color:#39bae6>uint32_t</span><span> max_entries</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=font-style:italic;color:#39bae6>uint16_t</span><span> data_size</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=font-style:italic;color:#39bae6>uint16_t</span><span> entry_idx</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=font-style:italic;color:#39bae6>uint16_t</span><span> queue_idx</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>char</span><span style=color:#f29668>*</span><span> data</span><span style=color:#bfbab0cc>;
</span><span>}</span><span style=color:#59c2ff>request_t</span><span style=color:#bfbab0cc>;
</span></code></pre><ol><li><strong>Create_kqueue</strong> -</ol><pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=color:#ff7733>static</span><span> noinline </span><span style=color:#ff7733>long </span><span style=color:#ffb454>create_kqueue</span><span>(request_t </span><span style=color:#f29718>request</span><span>){
</span><span>    </span><span style=color:#ff7733>long</span><span> result </span><span style=color:#f29668>=</span><span> INVALID</span><span style=color:#bfbab0cc>;
</span><span>
</span><span>    </span><span style=color:#ff7733>if</span><span>(queueCount </span><span style=color:#f29668>></span><span> MAX_QUEUES)
</span><span>        </span><span style=color:#ffb454>err</span><span>(</span><span style=color:#c2d94c>"[-] Max queue count reached"</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>
</span><span>    </span><span style=font-style:italic;color:#5c6773>/* You can't ask for 0 queues , how meaningless */
</span><span>    </span><span style=color:#ff7733>if</span><span>(request</span><span style=color:#f29668>.</span><span>max_entries</span><span style=color:#f29668><</span><span style=color:#f29718>1</span><span>)
</span><span>        </span><span style=color:#ffb454>err</span><span>(</span><span style=color:#c2d94c>"[-] kqueue entries should be greater than 0"</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>
</span><span>    </span><span style=font-style:italic;color:#5c6773>/* Asking for too much is also not good */
</span><span>    </span><span style=color:#ff7733>if</span><span>(request</span><span style=color:#f29668>.</span><span>data_size</span><span style=color:#f29668>></span><span>MAX_DATA_SIZE)
</span><span>        </span><span style=color:#ffb454>err</span><span>(</span><span style=color:#c2d94c>"[-] kqueue data size exceed"</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>
</span><span>    </span><span style=font-style:italic;color:#5c6773>/* Initialize kqueue_entry structure */
</span><span>    queue_entry </span><span style=color:#f29668>*</span><span>kqueue_entry</span><span style=color:#bfbab0cc>;
</span></code></pre><p>Here are the observations we can make from the necessary checks happening above -<ul><li><code>queueCount</code> must not exceed 5.<li><code>request.max_entries</code> should not be less than 1.<li><code>request.data_size</code> should not exceed 0x20.<li><code>request.data_size</code> is the size of each queue entry and within a queue , each entry has the same <code>data_size</code>.</ul><pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span>    </span><span style=font-style:italic;color:#5c6773>/* Check if multiplication of 2 64 bit integers results in overflow */
</span><span>    ull space </span><span style=color:#f29668>= </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>if</span><span>(</span><span style=color:#ffb454>__builtin_umulll_overflow</span><span>(</span><span style=color:#ff7733>sizeof</span><span>(queue_entry)</span><span style=color:#bfbab0cc>,</span><span>(request</span><span style=color:#f29668>.</span><span>max_entries</span><span style=color:#f29668>+</span><span style=color:#f29718>1</span><span>)</span><span style=color:#bfbab0cc>,</span><span style=color:#f29668>&</span><span>space) </span><span style=color:#f29668>== </span><span style=color:#f29718>true</span><span>)
</span><span>        </span><span style=color:#ffb454>err</span><span>(</span><span style=color:#c2d94c>"[-] Integer overflow"</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>
</span><span>    </span><span style=font-style:italic;color:#5c6773>/* Size is the size of queue structure + size of entry * request entries */
</span><span>    ull queue_size </span><span style=color:#f29668>= </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>if</span><span>(</span><span style=color:#ffb454>__builtin_saddll_overflow</span><span>(</span><span style=color:#ff7733>sizeof</span><span>(queue)</span><span style=color:#bfbab0cc>,</span><span>space</span><span style=color:#bfbab0cc>,</span><span style=color:#f29668>&</span><span>queue_size) </span><span style=color:#f29668>== </span><span style=color:#f29718>true</span><span>)
</span><span>        </span><span style=color:#ffb454>err</span><span>(</span><span style=color:#c2d94c>"[-] Integer overflow"</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>
</span><span>    </span><span style=font-style:italic;color:#5c6773>/* Total size should not exceed a certain limit */
</span><span>    </span><span style=color:#ff7733>if</span><span>(queue_size</span><span style=color:#f29668>></span><span style=color:#ff7733>sizeof</span><span>(queue) </span><span style=color:#f29668>+ </span><span style=color:#f29718>0x10000</span><span>)
</span><span>        </span><span style=color:#ffb454>err</span><span>(</span><span style=color:#c2d94c>"[-] Max kqueue alloc limit reached"</span><span>)</span><span style=color:#bfbab0cc>;
</span></code></pre><ul><li>Here we see that multiplication of <code>sizeof(queue_entry)</code> and <code>request.max_entries+1</code> is being stored in <code>space</code> after making sure that it doesn't overflow 64 bits.<li>We see the addition of <code>sizeof(queue)</code> and the above result of multiplication being stored in <code>queue_size</code>.</ul><p>So each queue is essentially creating space for it's entries , the number of entries come from the <code>request.max_entries</code> which determine the size of the entire queue.<pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span>    </span><span style=font-style:italic;color:#5c6773>/* All checks done , now call kmalloc */
</span><span>    queue </span><span style=color:#f29668>*</span><span>queue </span><span style=color:#f29668>= </span><span style=color:#ffb454>validate</span><span>((</span><span style=color:#ff7733>char </span><span style=color:#f29668>*</span><span>)</span><span style=color:#ffb454>kmalloc</span><span>(queue_size</span><span style=color:#bfbab0cc>,</span><span>GFP_KERNEL))</span><span style=color:#bfbab0cc>;
</span><span>
</span><span>    </span><span style=font-style:italic;color:#5c6773>/* Main queue can also store data */
</span><span>    queue</span><span style=color:#f29668>-></span><span>data </span><span style=color:#f29668>= </span><span style=color:#ffb454>validate</span><span>((</span><span style=color:#ff7733>char </span><span style=color:#f29668>*</span><span>)</span><span style=color:#ffb454>kmalloc</span><span>(request</span><span style=color:#f29668>.</span><span>data_size</span><span style=color:#bfbab0cc>,</span><span>GFP_KERNEL))</span><span style=color:#bfbab0cc>;
</span><span>
</span><span>    </span><span style=font-style:italic;color:#5c6773>/* Fill the remaining queue structure */
</span><span>    queue</span><span style=color:#f29668>-></span><span>data_size   </span><span style=color:#f29668>=</span><span> request</span><span style=color:#f29668>.</span><span>data_size</span><span style=color:#bfbab0cc>;
</span><span>    queue</span><span style=color:#f29668>-></span><span>max_entries </span><span style=color:#f29668>=</span><span> request</span><span style=color:#f29668>.</span><span>max_entries</span><span style=color:#bfbab0cc>;
</span><span>    queue</span><span style=color:#f29668>-></span><span>queue_size  </span><span style=color:#f29668>=</span><span> queue_size</span><span style=color:#bfbab0cc>;
</span></code></pre><p>Once above checks are done, the queue is allocated. Also since the <a href=https://pwnverse.github.io/posts/kqueue/#queue-structure>main queue</a> has a data field, it's data is allocated on heap.<p>After that, the queue structure fields are populated.<p>Every entry of queue also needs to be allocated memory for storing data , and this happens next.<pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span>    </span><span style=font-style:italic;color:#5c6773>/* Get to the place from where memory has to be handled */
</span><span>    kqueue_entry </span><span style=color:#f29668>= </span><span>(queue_entry </span><span style=color:#f29668>*</span><span>)((</span><span style=font-style:italic;color:#39bae6>uint64_t</span><span>)(queue </span><span style=color:#f29668>+ </span><span>(</span><span style=color:#ff7733>sizeof</span><span>(queue)</span><span style=color:#f29668>+</span><span style=color:#f29718>1</span><span>)</span><span style=color:#f29668>/</span><span style=color:#f29718>8</span><span>))</span><span style=color:#bfbab0cc>;
</span><span>
</span><span>    </span><span style=font-style:italic;color:#5c6773>/* Allocate all kqueue entries */
</span><span>    queue_entry</span><span style=color:#f29668>*</span><span> current_entry </span><span style=color:#f29668>=</span><span> kqueue_entry</span><span style=color:#bfbab0cc>;
</span><span>    queue_entry</span><span style=color:#f29668>*</span><span> prev_entry </span><span style=color:#f29668>=</span><span> current_entry</span><span style=color:#bfbab0cc>;
</span><span>
</span><span>    </span><span style=font-style:italic;color:#39bae6>uint32_t</span><span> i</span><span style=color:#f29668>=</span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>for</span><span>(i</span><span style=color:#f29668>=</span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>;</span><span>i</span><span style=color:#f29668><</span><span>request</span><span style=color:#f29668>.</span><span>max_entries</span><span style=color:#f29668>+</span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>;</span><span>i</span><span style=color:#f29668>++</span><span>){
</span><span>        </span><span style=color:#ff7733>if</span><span>(i</span><span style=color:#f29668>!=</span><span>request</span><span style=color:#f29668>.</span><span>max_entries)
</span><span>            prev_entry</span><span style=color:#f29668>-></span><span>next </span><span style=color:#f29668>= </span><span style=color:#f29718>NULL</span><span style=color:#bfbab0cc>;
</span><span>        current_entry</span><span style=color:#f29668>-></span><span>idx </span><span style=color:#f29668>=</span><span> i</span><span style=color:#bfbab0cc>;
</span><span>        current_entry</span><span style=color:#f29668>-></span><span>data </span><span style=color:#f29668>= </span><span>(</span><span style=color:#ff7733>char </span><span style=color:#f29668>*</span><span>)(</span><span style=color:#ffb454>validate</span><span>((</span><span style=color:#ff7733>char </span><span style=color:#f29668>*</span><span>)</span><span style=color:#ffb454>kmalloc</span><span>(request</span><span style=color:#f29668>.</span><span>data_size</span><span style=color:#bfbab0cc>,</span><span>GFP_KERNEL)))</span><span style=color:#bfbab0cc>;
</span><span>
</span><span>        </span><span style=font-style:italic;color:#5c6773>/* Increment current_entry by size of queue_entry */
</span><span>        current_entry </span><span style=color:#f29668>+= </span><span style=color:#ff7733>sizeof</span><span>(queue_entry)</span><span style=color:#f29668>/</span><span style=color:#f29718>16</span><span style=color:#bfbab0cc>;
</span><span>
</span><span>        </span><span style=font-style:italic;color:#5c6773>/* Populate next pointer of the previous entry */
</span><span>        prev_entry</span><span style=color:#f29668>-></span><span>next </span><span style=color:#f29668>=</span><span> current_entry</span><span style=color:#bfbab0cc>;
</span><span>        prev_entry </span><span style=color:#f29668>=</span><span> prev_entry</span><span style=color:#f29668>-></span><span>next</span><span style=color:#bfbab0cc>;
</span><span>    }
</span></code></pre><p>In the above code , we see how we now reach the memory location from where remaining entries of the queue need to be allocated.<ul><li>We iterate <code>max_entries</code> number of times, populate the <code>idx</code> field of the <a href=https://pwnverse.github.io/posts/kqueue/#structure-of-each-entry-in-queue>kqueue_entry</a>, the data field and finally populate the <code>next</code> pointer if more than 1 entries exist.</ul><pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span>    </span><span style=font-style:italic;color:#5c6773>/* Find an appropriate slot in kqueues */
</span><span>    </span><span style=font-style:italic;color:#39bae6>uint32_t</span><span> j </span><span style=color:#f29668>= </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>for</span><span>(j</span><span style=color:#f29668>=</span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;</span><span>j</span><span style=color:#f29668><</span><span>MAX_QUEUES</span><span style=color:#bfbab0cc>;</span><span>j</span><span style=color:#f29668>++</span><span>){
</span><span>        </span><span style=color:#ff7733>if</span><span>(kqueues[j] </span><span style=color:#f29668>== </span><span style=color:#f29718>NULL</span><span>)
</span><span>            </span><span style=color:#ff7733>break</span><span style=color:#bfbab0cc>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#ff7733>if</span><span>(j</span><span style=color:#f29668>></span><span>MAX_QUEUES)
</span><span>        </span><span style=color:#ffb454>err</span><span>(</span><span style=color:#c2d94c>"[-] No kqueue slot left"</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>
</span><span>    </span><span style=font-style:italic;color:#5c6773>/* Assign the newly created kqueue to the kqueues */
</span><span>    kqueues[j] </span><span style=color:#f29668>=</span><span> queue</span><span style=color:#bfbab0cc>;
</span><span>    queueCount</span><span style=color:#f29668>++</span><span style=color:#bfbab0cc>;
</span><span>    result </span><span style=color:#f29668>= </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>return</span><span> result</span><span style=color:#bfbab0cc>;
</span><span style=color:#ff3333>}
</span></code></pre><ul><li>Finally , after allocating memory for all queue entries, we now store the queue on a global array and increment the <code>queueCount</code>.</ul><p>Before going forward, let's have a visual look of memory when a queue gets allocated.<pre class=language-sh data-lang=sh style=background:#0f1419;color:#bfbab0><code class=language-sh data-lang=sh><span style=color:#ffb454>0xffff88801edfc3f8:</span><span>     0x0000000000000000 -</span><span style=color:#f29668>></span><span> queue_idx       0x0000000000000020 -</span><span style=color:#f29668>></span><span> data_size
</span><span style=color:#ffb454>0xffff88801edfc408:</span><span>     0x00000000000003f8 -</span><span style=color:#f29668>></span><span> queue_size      0x0000000000000028 -</span><span style=color:#f29668>></span><span> max_entries
</span><span style=color:#ffb454>0xffff88801edfc418:</span><span>     0xffff88801e3b4e60 -</span><span style=color:#f29668>></span><span> queue-</span><span style=color:#f29668>></span><span>data
</span></code></pre><p>After this , queue entries follow -<pre class=language-sh data-lang=sh style=background:#0f1419;color:#bfbab0><code class=language-sh data-lang=sh><span style=color:#ffb454>0xffff88801edfc420:</span><span>     0x0000000000000001 -</span><span style=color:#f29668>></span><span> idx      0xffff88801e3b4e40 -</span><span style=color:#f29668>></span><span> data
</span><span style=color:#ffb454>0xffff88801edfc430:</span><span>     0xffff88801edfc438 -</span><span style=color:#f29668>></span><span> next     0x0000000000000002
</span><span style=color:#ffb454>0xffff88801edfc440:</span><span>     0xffff88801e3b4e20             0xffff88801edfc450
</span><span style=color:#ffb454>0xffff88801edfc450:</span><span>     0x0000000000000003             0xffff88801e3b4e00
</span><span style=color:#ffb454>0xffff88801edfc460:</span><span>     0xffff88801edfc468             
</span><span style=color:#ffb454>...
</span></code></pre><ol start=2><li><strong>Delete Kqueue</strong></ol><pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=color:#ff7733>static</span><span> noinline </span><span style=color:#ff7733>long </span><span style=color:#ffb454>delete_kqueue</span><span>(request_t </span><span style=color:#f29718>request</span><span>){  
</span><span>    </span><span style=font-style:italic;color:#5c6773>/* Check for out of bounds requests */              
</span><span>    </span><span style=color:#ff7733>if</span><span>(request</span><span style=color:#f29668>.</span><span>queue_idx</span><span style=color:#f29668>></span><span>MAX_QUEUES)                    
</span><span>        </span><span style=color:#ffb454>err</span><span>(</span><span style=color:#c2d94c>"[-] Invalid idx"</span><span>)</span><span style=color:#bfbab0cc>;                         
</span><span>                                                        
</span><span>    </span><span style=font-style:italic;color:#5c6773>/* Check for existence of the request kqueue */     
</span><span>    queue </span><span style=color:#f29668>*</span><span>queue </span><span style=color:#f29668>=</span><span> kqueues[request</span><span style=color:#f29668>.</span><span>queue_idx]</span><span style=color:#bfbab0cc>;          
</span><span>    </span><span style=color:#ff7733>if</span><span>(</span><span style=color:#f29668>!</span><span>queue)                                          
</span><span>        </span><span style=color:#ffb454>err</span><span>(</span><span style=color:#c2d94c>"[-] Requested kqueue does not exist"</span><span>)</span><span style=color:#bfbab0cc>;     
</span><span>                                                        
</span><span>    </span><span style=color:#f07178>memset</span><span>(queue</span><span style=color:#bfbab0cc>,</span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>,</span><span>queue</span><span style=color:#f29668>-></span><span>queue_size)</span><span style=color:#bfbab0cc>;                  
</span><span>    </span><span style=color:#ffb454>kfree</span><span>(queue)</span><span style=color:#bfbab0cc>;                                       
</span><span>    kqueues[request</span><span style=color:#f29668>.</span><span>queue_idx] </span><span style=color:#f29668>= </span><span style=color:#f29718>NULL</span><span style=color:#bfbab0cc>;                  
</span><span>    </span><span style=color:#ff7733>return </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;                                           
</span><span>}                                                       
</span></code></pre><ul><li>This function just frees the kqueue and nulls out it's memory.</ul><ol start=3><li><strong>Edit Kqueue</strong></ol><pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=color:#ff7733>static</span><span> noinline </span><span style=color:#ff7733>long </span><span style=color:#ffb454>edit_kqueue</span><span>(request_t </span><span style=color:#f29718>request</span><span>){
</span><span>    </span><span style=font-style:italic;color:#5c6773>/* Check the idx of the kqueue */                                              
</span><span>    </span><span style=color:#ff7733>if</span><span>(request</span><span style=color:#f29668>.</span><span>queue_idx </span><span style=color:#f29668>></span><span> MAX_QUEUES)                                             
</span><span>        </span><span style=color:#ffb454>err</span><span>(</span><span style=color:#c2d94c>"[-] Invalid kqueue idx"</span><span>)</span><span style=color:#bfbab0cc>;                                             
</span><span>                                                                                   
</span><span>    </span><span style=font-style:italic;color:#5c6773>/* Check if the kqueue exists at that idx */                                   
</span><span>    queue </span><span style=color:#f29668>*</span><span>queue </span><span style=color:#f29668>=</span><span> kqueues[request</span><span style=color:#f29668>.</span><span>queue_idx]</span><span style=color:#bfbab0cc>;                                     
</span><span>    </span><span style=color:#ff7733>if</span><span>(</span><span style=color:#f29668>!</span><span>queue)                                                                     
</span><span>        </span><span style=color:#ffb454>err</span><span>(</span><span style=color:#c2d94c>"[-] kqueue does not exist"</span><span>)</span><span style=color:#bfbab0cc>;                                          
</span><span>                                                                                   
</span><span>    </span><span style=font-style:italic;color:#5c6773>/* Check the idx of the kqueue entry */                                        
</span><span>    </span><span style=color:#ff7733>if</span><span>(request</span><span style=color:#f29668>.</span><span>entry_idx </span><span style=color:#f29668>></span><span> queue</span><span style=color:#f29668>-></span><span>max_entries)                                     
</span><span>        </span><span style=color:#ffb454>err</span><span>(</span><span style=color:#c2d94c>"[-] Invalid kqueue entry_idx"</span><span>)</span><span style=color:#bfbab0cc>;                                       
</span><span>                                                                                   
</span><span>    </span><span style=font-style:italic;color:#5c6773>/* Get to the kqueue entry memory */                                           
</span><span>    queue_entry </span><span style=color:#f29668>*</span><span>kqueue_entry </span><span style=color:#f29668>= </span><span>(queue_entry </span><span style=color:#f29668>*</span><span>)(queue </span><span style=color:#f29668>+ </span><span>(</span><span style=color:#ff7733>sizeof</span><span>(queue)</span><span style=color:#f29668>+</span><span style=color:#f29718>1</span><span>)</span><span style=color:#f29668>/</span><span style=color:#f29718>8</span><span>)</span><span style=color:#bfbab0cc>;      
</span><span>                                                                                   
</span><span>    </span><span style=font-style:italic;color:#5c6773>/* Check for the existence of the kqueue entry */                              
</span><span>    exists </span><span style=color:#f29668>= </span><span style=color:#f29718>false</span><span style=color:#bfbab0cc>;                                                                
</span><span>    </span><span style=font-style:italic;color:#39bae6>uint32_t</span><span> i</span><span style=color:#f29668>=</span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>;                                                                  
</span><span>    </span><span style=color:#ff7733>for</span><span>(i</span><span style=color:#f29668>=</span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>;</span><span>i</span><span style=color:#f29668><</span><span>queue</span><span style=color:#f29668>-></span><span>max_entries</span><span style=color:#f29668>+</span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>;</span><span>i</span><span style=color:#f29668>++</span><span>){                                           
</span><span>                                                                                   
</span><span>        </span><span style=font-style:italic;color:#5c6773>/* If kqueue entry found , do the necessary */                             
</span><span>        </span><span style=color:#ff7733>if</span><span>(kqueue_entry </span><span style=color:#f29668>&&</span><span> request</span><span style=color:#f29668>.</span><span>data </span><span style=color:#f29668>&&</span><span> queue</span><span style=color:#f29668>-></span><span>data_size){                      
</span><span>            </span><span style=color:#ff7733>if</span><span>(kqueue_entry</span><span style=color:#f29668>-></span><span>idx </span><span style=color:#f29668>==</span><span> request</span><span style=color:#f29668>.</span><span>entry_idx){                            
</span><span>                </span><span style=color:#ffb454>validate</span><span>(</span><span style=color:#f07178>memcpy</span><span>(kqueue_entry</span><span style=color:#f29668>-></span><span>data</span><span style=color:#bfbab0cc>,</span><span>request</span><span style=color:#f29668>.</span><span>data</span><span style=color:#bfbab0cc>,</span><span>queue</span><span style=color:#f29668>-></span><span>data_size))</span><span style=color:#bfbab0cc>;
</span><span>                exists </span><span style=color:#f29668>= </span><span style=color:#f29718>true</span><span style=color:#bfbab0cc>;                                                     
</span><span>            }                                                                      
</span><span>        }                                                                          
</span><span>        kqueue_entry </span><span style=color:#f29668>=</span><span> kqueue_entry</span><span style=color:#f29668>-></span><span>next</span><span style=color:#bfbab0cc>;                                         
</span><span>    }                                                                              
</span><span>                                                                                   
</span><span>    </span><span style=font-style:italic;color:#5c6773>/* What if the idx is 0, it means we have to update the main kqueue's data */  
</span><span>    </span><span style=color:#ff7733>if</span><span>(request</span><span style=color:#f29668>.</span><span>entry_idx</span><span style=color:#f29668>==</span><span style=color:#f29718>0 </span><span style=color:#f29668>&&</span><span> kqueue_entry </span><span style=color:#f29668>&&</span><span> request</span><span style=color:#f29668>.</span><span>data </span><span style=color:#f29668>&&</span><span> queue</span><span style=color:#f29668>-></span><span>data_size){  
</span><span>        </span><span style=color:#ffb454>validate</span><span>(</span><span style=color:#f07178>memcpy</span><span>(queue</span><span style=color:#f29668>-></span><span>data</span><span style=color:#bfbab0cc>,</span><span>request</span><span style=color:#f29668>.</span><span>data</span><span style=color:#bfbab0cc>,</span><span>queue</span><span style=color:#f29668>-></span><span>data_size))</span><span style=color:#bfbab0cc>;               
</span><span>        </span><span style=color:#ff7733>return </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;                                                                  
</span></code></pre><ul><li>This function basically iterates through the entries of the requested queue and copies <code>request.data</code> into <code>kqueue_entry->data</code>.</ul><ol start=4><li><strong>Save Kqueue</strong></ol><pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=font-style:italic;color:#5c6773>/* Now you have the option to safely preserve your precious kqueues */         
</span><span style=color:#ff7733>static</span><span> noinline </span><span style=color:#ff7733>long </span><span style=color:#ffb454>save_kqueue_entries</span><span>(request_t </span><span style=color:#f29718>request</span><span>){                   
</span><span>                                                                               
</span><span>    </span><span style=font-style:italic;color:#5c6773>/* Check for out of bounds queue_idx requests */                           
</span><span>    </span><span style=color:#ff7733>if</span><span>(request</span><span style=color:#f29668>.</span><span>queue_idx </span><span style=color:#f29668>></span><span> MAX_QUEUES)                                         
</span><span>        </span><span style=color:#ffb454>err</span><span>(</span><span style=color:#c2d94c>"[-] Invalid kqueue idx"</span><span>)</span><span style=color:#bfbab0cc>;                                         
</span><span>                                                                               
</span><span>    </span><span style=font-style:italic;color:#5c6773>/* Check if queue is already saved or not */                               
</span><span>    </span><span style=color:#ff7733>if</span><span>(isSaved[request</span><span style=color:#f29668>.</span><span>queue_idx]</span><span style=color:#f29668>==</span><span style=color:#f29718>true</span><span>)                                       
</span><span>        </span><span style=color:#ffb454>err</span><span>(</span><span style=color:#c2d94c>"[-] Queue already saved"</span><span>)</span><span style=color:#bfbab0cc>;                                        
</span><span>                                                                               
</span><span>    queue </span><span style=color:#f29668>*</span><span>queue </span><span style=color:#f29668>= </span><span style=color:#ffb454>validate</span><span>(kqueues[request</span><span style=color:#f29668>.</span><span>queue_idx])</span><span style=color:#bfbab0cc>;                       
</span><span>                                                                               
</span><span>    </span><span style=font-style:italic;color:#5c6773>/* Check if number of requested entries exceed the existing entries */     
</span><span>    </span><span style=color:#ff7733>if</span><span>(request</span><span style=color:#f29668>.</span><span>max_entries </span><span style=color:#f29668>< </span><span style=color:#f29718>1 </span><span style=color:#f29668>||</span><span> request</span><span style=color:#f29668>.</span><span>max_entries </span><span style=color:#f29668>></span><span> queue</span><span style=color:#f29668>-></span><span>max_entries)    
</span><span>        </span><span style=color:#ffb454>err</span><span>(</span><span style=color:#c2d94c>"[-] Invalid entry count"</span><span>)</span><span style=color:#bfbab0cc>;                                        
</span></code></pre><p>Basic checks which ensure no out of bound access. We also check if <code>request.max_entries</code> are greater than <code>queue->max_entries</code>.<pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span>
</span><span>    </span><span style=font-style:italic;color:#5c6773>/* Each saved entry can have its own size */                                 
</span><span>    </span><span style=color:#ff7733>if</span><span>(request</span><span style=color:#f29668>.</span><span>data_size </span><span style=color:#f29668>></span><span> queue</span><span style=color:#f29668>-></span><span>queue_size)                                     
</span><span>        </span><span style=color:#ffb454>err</span><span>(</span><span style=color:#c2d94c>"[-] Entry size limit exceed"</span><span>)</span><span style=color:#bfbab0cc>; 
</span><span>
</span><span>    </span><span style=font-style:italic;color:#5c6773>/* Allocate memory for the kqueue to be saved */                             
</span><span>    </span><span style=color:#ff7733>char </span><span style=color:#f29668>*</span><span>new_queue </span><span style=color:#f29668>= </span><span style=color:#ffb454>validate</span><span>((</span><span style=color:#ff7733>char </span><span style=color:#f29668>*</span><span>)</span><span style=color:#ffb454>kzalloc</span><span>(queue</span><span style=color:#f29668>-></span><span>queue_size</span><span style=color:#bfbab0cc>,</span><span>GFP_KERNEL)</span><span style=color:#bfbab0cc>;                                  
</span><span>
</span><span>
</span><span>    </span><span style=font-style:italic;color:#5c6773>/* Copy main's queue's data */                                               
</span><span>    </span><span style=color:#ff7733>if</span><span>(queue</span><span style=color:#f29668>-></span><span>data </span><span style=color:#f29668>&&</span><span> request</span><span style=color:#f29668>.</span><span>data_size)                                         
</span><span>        </span><span style=color:#ffb454>validate</span><span>(</span><span style=color:#f07178>memcpy</span><span>(new_queue</span><span style=color:#bfbab0cc>,</span><span>queue</span><span style=color:#f29668>-></span><span>data</span><span style=color:#bfbab0cc>,</span><span>request</span><span style=color:#f29668>.</span><span>data_size))</span><span style=color:#bfbab0cc>;               
</span><span>    </span><span style=color:#ff7733>else                                                                         
</span><span>        </span><span style=color:#ffb454>err</span><span>(</span><span style=color:#c2d94c>"[-] Internal error"</span><span>)</span><span style=color:#bfbab0cc>;                                               
</span><span>    new_queue </span><span style=color:#f29668>+=</span><span> queue</span><span style=color:#f29668>-></span><span>data_size</span><span style=color:#bfbab0cc>;                                               
</span></code></pre><ul><li>Here , <code>request.data_size</code> is checked against <code>queue->queue_size</code> which obviously paves a straight away path for a heap overflow.</ul><p><code>request.data_size</code> can be large enough and eventually , the memory allocated for the <code>max_entries</code> will overflow into the next chunk.<p><strong>Note</strong> - This was actually unintended on my part, the proper way of exploiting the challenge was through abusing the integer overflow which I will nevertheless discuss about in a moment.<ul><li><code>kzalloc</code> is called to allocate memory for the new queue.<li>First , data of main queue is copied to the new queue.<li>Subsequently, we iterate through max_entries and copy data of other entries as well.</ul><pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span>    </span><span style=font-style:italic;color:#5c6773>/* copy all possible kqueue entries */                                    
</span><span>    </span><span style=font-style:italic;color:#39bae6>uint32_t</span><span> i</span><span style=color:#f29668>=</span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;                                                             
</span><span>    </span><span style=color:#ff7733>for</span><span>(i</span><span style=color:#f29668>=</span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>;</span><span>i</span><span style=color:#f29668><</span><span>request</span><span style=color:#f29668>.</span><span>max_entries</span><span style=color:#f29668>+</span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>;</span><span>i</span><span style=color:#f29668>++</span><span>){                                     
</span><span>        </span><span style=color:#ff7733>if</span><span>(</span><span style=color:#f29668>!</span><span>kqueue_entry </span><span style=color:#f29668>|| !</span><span>kqueue_entry</span><span style=color:#f29668>-></span><span>data)                              
</span><span>            </span><span style=color:#ff7733>break</span><span style=color:#bfbab0cc>;                                                            
</span><span>        </span><span style=color:#ff7733>if</span><span>(kqueue_entry</span><span style=color:#f29668>-></span><span>data </span><span style=color:#f29668>&&</span><span> request</span><span style=color:#f29668>.</span><span>data_size)                           
</span><span>            </span><span style=color:#ffb454>validate</span><span>(</span><span style=color:#f07178>memcpy</span><span>(new_queue</span><span style=color:#bfbab0cc>,</span><span>kqueue_entry</span><span style=color:#f29668>-></span><span>data</span><span style=color:#bfbab0cc>,</span><span>request</span><span style=color:#f29668>.</span><span>data_size))</span><span style=color:#bfbab0cc>; 
</span><span>        </span><span style=color:#ff7733>else                                                                  
</span><span>            </span><span style=color:#ffb454>err</span><span>(</span><span style=color:#c2d94c>"[-] Internal error"</span><span>)</span><span style=color:#bfbab0cc>;                                        
</span><span>        kqueue_entry </span><span style=color:#f29668>=</span><span> kqueue_entry</span><span style=color:#f29668>-></span><span>next</span><span style=color:#bfbab0cc>;                                    
</span><span>        new_queue </span><span style=color:#f29668>+=</span><span> queue</span><span style=color:#f29668>-></span><span>data_size</span><span style=color:#bfbab0cc>;                                        
</span><span>    }                                                                         
</span><span>                                                                              
</span><span>    </span><span style=font-style:italic;color:#5c6773>/* Mark the queue as saved */                                             
</span><span>    isSaved[request</span><span style=color:#f29668>.</span><span>queue_idx] </span><span style=color:#f29668>= </span><span style=color:#f29718>true</span><span style=color:#bfbab0cc>;                                        
</span><span>    </span><span style=color:#ff7733>return </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;                                                                 
</span><span style=color:#ff3333>}                                                                             
</span></code></pre><p>Finally , we mark the queue as saved , note that a saved queue cannot be saved again.<h2 id=idea-of-exploitation>Idea of exploitation</h2><pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span>    </span><span style=color:#ff7733>if</span><span>(</span><span style=color:#ffb454>__builtin_umulll_overflow</span><span>(</span><span style=color:#ff7733>sizeof</span><span>(queue_entry)</span><span style=color:#bfbab0cc>,</span><span>(request</span><span style=color:#f29668>.</span><span>max_entries</span><span style=color:#f29668>+</span><span style=color:#f29718>1</span><span>)</span><span style=color:#bfbab0cc>,</span><span style=color:#f29668>&</span><span>space) </span><span style=color:#f29668>== </span><span style=color:#f29718>true</span><span>)                                                                         
</span></code></pre><p>Since there's no check on <code>request.max_entries</code>, a <code>0xffffffff</code> as max_entries results in integer overflow. This when coupled with the save option can result in a heap overflow.<p>With the heap overflow , since smep is disabled, we can overwrite it with pointer to userspace shellcode. There is no need of leaks since we have shellcode execution , we can easily control some register which already points to a kernel code address and change it to point to any function we wish to call in kernel.<h2 id=conclusion>Conclusion</h2><p>The challenge could have been made better by enabling smep and smap , it would have been more fun to leak kernel pointers with partial overwrites but yes , the exploit would have been a lot less reliable in that case.<p><a href=https://gist.github.com/PwnVerse/88d078653bb810759d86564dbc2258a6>Here</a> is the complete exploit.<p>Flag - <code>inctf{l3akl3ss_r1p_w1th_u5erSp4ce_7rick3ry}</code></section></article></main></div>