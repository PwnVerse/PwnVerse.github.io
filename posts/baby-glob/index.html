<!doctype html><html class="dark light"><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Baby Glob - InCTF Internationals 2021
        
    </title><meta content="Baby Glob - InCTF Internationals 2021" property=og:title><link href=https://pwnverse.github.io/fonts.css rel=stylesheet><script>(function(){var a=document.createElement('script');a.setAttribute('src','/js/imamu.js');a.setAttribute('data-website-id','74344cd8-1e87-4c38-8acd-f96049b8f07e');a.setAttribute('data-host-url','https:&#x2F;&#x2F;analytics.eu.umami.is');document.body.appendChild(a)})()</script><script async data-host-url=https://analytics.eu.umami.is data-website-id=74344cd8-1e87-4c38-8acd-f96049b8f07e src=/js/imamu.js></script><script async data-goatcounter=https://Cyb0rG.goatcounter.com/count src=https://pwnverse.github.io/js/count.js></script><noscript><img src="https://Cyb0rG.goatcounter.com//count?p=/posts/baby-glob/&t=Baby Glob - InCTF Internationals 2021"></noscript><link title="Cyb0rG's Home" href=https://pwnverse.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://pwnverse.github.io/theme/light.css rel=stylesheet><link href=https://pwnverse.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><link href=https://pwnverse.github.io/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://pwnverse.github.io>Cyb0rG's Home</a><div class=socials><a class=social href=https://twitter.com/_Cyb0rG rel=me> <img alt=twitter src=/social_icons/twitter.svg> </a><a class=social href=https://github.com/PwnVerse/ rel=me> <img alt=github src=/social_icons/github.svg> </a></div></div><nav><a href=/posts style=margin-left:.7em>/posts</a><a href=/projects style=margin-left:.7em>/projects</a><a href=/about style=margin-left:.7em>/about</a> | <a href=javascript:void(0) id=dark-mode-toggle onclick=toggleTheme()> <img id=sun-icon src=/feather/sun.svg style=filter:invert(1)> <img id=moon-icon src=/feather/moon.svg> </a><script src=https://pwnverse.github.io/js/themetoggle.js></script></nav></header><main><article><div class=title><div class=page-header>Baby Glob - InCTF Internationals 2021<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2021-08-17</time></div></div><section class=body><p><strong>tl;dr</strong><ul><li>Heap Overflow in glob function while handling <code>Tilde</code> operator.<li>Abuse null byte overflow to gain RCE.</ul><p><strong>Challenge Points:</strong> 983 <strong>No of Solves:</strong> 9 <strong>Challenge Author:</strong> <a href=https://twitter.com/_Cyb0rG>Cyb0rG</a><h2 id=challenge-description>Challenge Description</h2><p><code>A Super secure path finder from your own 2017.</code><p>To start with , the challenge handout folder contains the binary , <code>chall.c</code> and <code>glob.c</code>.<p>The binary is a standard CTF-style executable. According to the description , the challenge is running on standard <code>ubuntu 20.04</code> docker container so the libc naturally is <code>2.31</code>.<h2 id=initial-analysis>Initial Analysis</h2><p>There are 4 straightforward functions<ol><li><strong>Add Path</strong> - Takes a pattern of user supplied size (limited to 0x1000) , mallocs it and stores it in a global array of patterns.<li><strong>Check Path</strong> - Takes an index , and uses the <code>glob</code> function to check if there exists a pathname matching the pattern.<li><strong>View Path</strong> - Takes an index and prints the pattern.<li><strong>Remove Path</strong> - Frees the memory containing the pattern at a user specified index , and nulls out the global array.</ol><p>It is fairly trivial to get a libc leak , since malloc is used and size limit is 0x1000 , we can easily leak a libc main arena pointer to start with.<p>But where is the actual exploitable bug? The answer partly lies in the description as well as the <code>glob.c</code> provided. A quick internet search on <code>glob cve 2017</code> quickly reveals the presence of an overflow while mishandling the <code>Tilde</code> operator. A little more research reveals a public <a href="https://sourceware.org/bugzilla/attachment.cgi?id=10549&action=edit">poc</a> available too.<p>Using the poc , we can see that we immediately trigger crash with <code>malloc() corrupted top chunk</code>.<h2 id=analysis-of-cve-2017-15804>Analysis of CVE-2017-15804</h2><p>The code path which triggers the heap overflow is as follows -<p>In <code>glob.c line: 523</code> , the first call to malloc happens and the data string is stored on heap.<pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span>    </span><span style=color:#ff7733>else
</span><span>      {
</span><span>        newp </span><span style=color:#f29668>= </span><span style=color:#f07178>malloc </span><span>(dirlen </span><span style=color:#f29668>+ </span><span style=color:#f29718>1</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#ff7733>if </span><span>(newp </span><span style=color:#f29668>== </span><span style=color:#f29718>NULL</span><span>)
</span><span>          </span><span style=color:#ff7733>return</span><span> GLOB_NOSPACE</span><span style=color:#bfbab0cc>;
</span><span>        malloc_dirname </span><span style=color:#f29668>= </span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>;
</span><span>      }
</span><span>    </span><span style=color:#f29668>*</span><span>((</span><span style=color:#ff7733>char </span><span style=color:#f29668>*</span><span>) </span><span style=color:#ffb454>mempcpy </span><span>(newp</span><span style=color:#bfbab0cc>,</span><span> pattern</span><span style=color:#bfbab0cc>,</span><span> dirlen)) </span><span style=color:#f29668>= </span><span style=color:#c2d94c>'</span><span style=color:#95e6cb>\0</span><span style=color:#c2d94c>'</span><span style=color:#bfbab0cc>;
</span><span>    dirname </span><span style=color:#f29668>=</span><span> newp</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f29668>++</span><span>filename</span><span style=color:#bfbab0cc>;
</span></code></pre><p>We are interested in the part of code from <code>line: 575 of glob.c</code><pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span>  </span><span style=color:#ff7733>if </span><span>((flags </span><span style=color:#f29668>& </span><span>(GLOB_TILDE</span><span style=color:#f29668>|</span><span>GLOB_TILDE_CHECK)) </span><span style=color:#f29668>&&</span><span> dirname[</span><span style=color:#f29718>0</span><span>] </span><span style=color:#f29668>== </span><span style=color:#c2d94c>'~'</span><span>)
</span></code></pre><ul><li>The very first character should be <code>~</code> and the flags should have the GLOB_TILDE to get into the if condition.</ul><p>Now , from <code>line: 709 of glob.c</code> , we see -<pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span>         </span><span style=color:#ff7733>char </span><span style=color:#f29668>*</span><span>end_name </span><span style=color:#f29668>= </span><span style=color:#f07178>strchr </span><span>(dirname</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>'/'</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>         </span><span style=color:#ff7733>char </span><span style=color:#f29668>*</span><span>user_name</span><span style=color:#bfbab0cc>;
</span><span>         </span><span style=color:#ff7733>int</span><span> malloc_user_name </span><span style=color:#f29668>= </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;
</span><span>         </span><span style=color:#ff7733>char </span><span style=color:#f29668>*</span><span>unescape </span><span style=color:#f29668>= </span><span style=color:#f29718>NULL</span><span style=color:#bfbab0cc>;
</span><span>
</span><span>         </span><span style=color:#ff7733>if </span><span>(</span><span style=color:#f29668>!</span><span>(flags </span><span style=color:#f29668>&</span><span> GLOB_NOESCAPE))
</span><span>           {
</span><span>             </span><span style=color:#ff7733>if </span><span>(end_name </span><span style=color:#f29668>== </span><span style=color:#f29718>NULL</span><span>)
</span><span>               {
</span><span>                 unescape </span><span style=color:#f29668>= </span><span style=color:#f07178>strchr </span><span>(dirname</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>'</span><span style=color:#95e6cb>\\</span><span style=color:#c2d94c>'</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>                 </span><span style=color:#ff7733>if </span><span>(unescape)
</span><span>                   end_name </span><span style=color:#f29668>= </span><span style=color:#f07178>strchr </span><span>(unescape</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>'</span><span style=color:#95e6cb>\0</span><span style=color:#c2d94c>'</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>               }
</span><span>             </span><span style=color:#ff7733>else
</span><span>               unescape </span><span style=color:#f29668>= </span><span style=color:#f07178>memchr </span><span>(dirname</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>'</span><span style=color:#95e6cb>\\</span><span style=color:#c2d94c>'</span><span style=color:#bfbab0cc>,</span><span> end_name </span><span style=color:#f29668>-</span><span> dirname)</span><span style=color:#bfbab0cc>;
</span><span>           }
</span><span>         </span><span style=color:#ff7733>if </span><span>(end_name </span><span style=color:#f29668>== </span><span style=color:#f29718>NULL</span><span>)
</span><span>           user_name </span><span style=color:#f29668>=</span><span> dirname </span><span style=color:#f29668>+ </span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>;
</span></code></pre><ul><li>Input must contain a <code>/</code> so that the <code>end_name</code> is not null and we reach the else condition where <code>unescape</code> is initialized.<li>Input should also contain <code>\\</code> as unescape should not be null for triggering the heap overflow.</ul><p>If all this is well , another malloc is called to store the string of size <code>end_name - dir_name</code>.<p>We have a lot of variables on out plate , so let's just list them all together at once.<ol><li>newp = malloc(endname - dirname)<li>dirname = input pointer<li>endname = address of first occurence of <code>/</code><li>unescape = address of first occurence of <code>\\</code></ol><p>The following <code>if</code> condition is the actual cause of heap overflow.<pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=color:#ff7733>if </span><span>(unescape </span><span style=color:#f29668>!= </span><span style=color:#f29718>NULL</span><span>)
</span><span>  {
</span><span>    </span><span style=color:#ff7733>char </span><span style=color:#f29668>*</span><span>p </span><span style=color:#f29668>= </span><span style=color:#ffb454>mempcpy </span><span>(newp</span><span style=color:#bfbab0cc>,</span><span> dirname </span><span style=color:#f29668>+ </span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>,
</span><span>                       unescape </span><span style=color:#f29668>-</span><span> dirname </span><span style=color:#f29668>- </span><span style=color:#f29718>1</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>char </span><span style=color:#f29668>*</span><span>q </span><span style=color:#f29668>=</span><span> unescape</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>while </span><span>(</span><span style=color:#f29668>*</span><span>q </span><span style=color:#f29668>!= </span><span style=color:#c2d94c>'</span><span style=color:#95e6cb>\0</span><span style=color:#c2d94c>'</span><span>)
</span><span>      {
</span><span>        </span><span style=color:#ff7733>if </span><span>(</span><span style=color:#f29668>*</span><span>q </span><span style=color:#f29668>== </span><span style=color:#c2d94c>'</span><span style=color:#95e6cb>\\</span><span style=color:#c2d94c>'</span><span>)
</span><span>          {
</span><span>            </span><span style=color:#ff7733>if </span><span>(q[</span><span style=color:#f29718>1</span><span>] </span><span style=color:#f29668>== </span><span style=color:#c2d94c>'</span><span style=color:#95e6cb>\0</span><span style=color:#c2d94c>'</span><span>)
</span><span>              {
</span><span>                </span><span style=font-style:italic;color:#5c6773>/* "~fo\\o\\" unescape to user_name "foo\\",
</span><span style=font-style:italic;color:#5c6773>                   but "~fo\\o\\/" unescape to user_name
</span><span style=font-style:italic;color:#5c6773>                   "foo".  */
</span><span>                </span><span style=color:#ff7733>if </span><span>(filename </span><span style=color:#f29668>== </span><span style=color:#f29718>NULL</span><span>)
</span><span>                  </span><span style=color:#f29668>*</span><span>p</span><span style=color:#f29668>++ = </span><span style=color:#c2d94c>'</span><span style=color:#95e6cb>\\</span><span style=color:#c2d94c>'</span><span style=color:#bfbab0cc>;
</span><span>                </span><span style=color:#ff7733>break</span><span style=color:#bfbab0cc>;
</span><span>              }
</span><span>            </span><span style=color:#f29668>++</span><span>q</span><span style=color:#bfbab0cc>;
</span><span>          }
</span><span>        </span><span style=color:#f29668>*</span><span>p</span><span style=color:#f29668>++ = *</span><span>q</span><span style=color:#f29668>++</span><span style=color:#bfbab0cc>;
</span><span>      }
</span><span>    </span><span style=color:#f29668>*</span><span>p </span><span style=color:#f29668>= </span><span style=color:#c2d94c>'</span><span style=color:#95e6cb>\0</span><span style=color:#c2d94c>'</span><span style=color:#bfbab0cc>;
</span><span>  }
</span></code></pre><ul><li>The call to <code>mempcpy</code> copies into the <code>newp</code> pointer , input of size <code>unescape - dirname - 1</code>.<li>In a while loop , it is checked if the unescape string is <code>\\</code> , if not , the character at <code>unescape</code> is copied into the region after mempcpy.</ul><p><strong>Observation</strong> : It keeps copying the entire string without any out of bounds check and thus causes the heap overflow.<h2 id=exploit-idea>Exploit Idea</h2><p>Using the public poc , we can check in gdb how things look and do some basic crash analysis.<p>In one iteration<pre class=language-sh data-lang=sh style=background:#0f1419;color:#bfbab0><code class=language-sh data-lang=sh><span style=color:#ffb454>0x55555555b390:</span><span>	0x0000000000000000	0x0000000000000061
</span><span style=color:#ffb454>0x55555555b3a0:</span><span>	0x6161616161616161	0x6161616161616161
</span><span style=color:#ffb454>0x55555555b3b0:</span><span>	0x6161616161616161	0x6161616161616161
</span><span style=color:#ffb454>0x55555555b3c0:</span><span>	0x6161616161616161	0x6161616161616477
</span><span style=color:#ffb454>0x55555555b3d0:</span><span>	0x6161616161616161	0x6161616161616161
</span><span style=color:#ffb454>0x55555555b3e0:</span><span>	0x6161616161616161	0x6161616161616161
</span><span style=color:#ffb454>0x55555555b3f0:</span><span>	0x2f2f2f2f2f2f6161	0x0000000000020c11 </span><span style=color:#f29668><</span><span style=color:#bfbab0cc>-</span><span> top chunk
</span></code></pre><p>In next iteration<pre class=language-sh data-lang=sh style=background:#0f1419;color:#bfbab0><code class=language-sh data-lang=sh><span style=color:#ffb454>0x55555555b390:</span><span>	0x0000000000000000	0x0000000000000061
</span><span style=color:#ffb454>0x55555555b3a0:</span><span>	0x6161616161616161	0x6161616161616161
</span><span style=color:#ffb454>0x55555555b3b0:</span><span>	0x6161616161616161	0x6161616161616161
</span><span style=color:#ffb454>0x55555555b3c0:</span><span>	0x6161616161616161	0x6161616161616477
</span><span style=color:#ffb454>0x55555555b3d0:</span><span>	0x6161616161616161	0x6161616161616161
</span><span style=color:#ffb454>0x55555555b3e0:</span><span>	0x6161616161616161	0x6161616161616161
</span><span style=color:#ffb454>0x55555555b3f0:</span><span>	0x2f2f2f2f2f2f6161	0x0000000000020c2f </span><span style=color:#f29668><</span><span style=color:#bfbab0cc>-</span><span> top chunk corrupted with input
</span></code></pre><p>This is what causes the <code>malloc() corrupted top</code>.<p>For the sake of ease of debugging , I have provided the challenge binary with debug symbols and source code stepping within gdb.<h3 id=null-byte-to-the-rescue>Null byte to the rescue</h3><p>After playing around with the poc and tweaking it a bit , we realize that overflow is happening only with <code>0x2f</code> byte which really isnt very interesting in terms of overwriting a tcache pointer fd or unsorted bin since it's not aligned. But with some effort and tweaking the poc , we can actually get a null byte overflow which is very powerful primitive as we all know.<p>With the null byte overflow , we can easily point tcache fd of a chunk to point to a fake chunk which resides at the memory ending with <code>\x00</code>. With this , we can successfully construct a fake chunk containing <code>free_hook</code> as fd.<h2 id=conclusion>Conclusion</h2><p>I had randomly come across this CVE and found it very interesting, I hope you enjoyed solving the challenge.<p><a href=https://gist.github.com/PwnVerse/d4d73d38c06b6cc20be4de9e98f16bbe>Here</a> is the complete exploit.<p>Flag - <code>inctf{CVE-2017-15804_Subtl3_H3ap_Overfl0w}</code></section></article></main></div>