<!doctype html><html class="dark light"><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Leakguard - HackTheVote 2020
        
    </title><meta content="Leakguard - HackTheVote 2020" property=og:title><link href=https://pwnverse.github.io/fonts.css rel=stylesheet><script>(function(){var a=document.createElement('script');a.setAttribute('src','/js/imamu.js');a.setAttribute('data-website-id','74344cd8-1e87-4c38-8acd-f96049b8f07e');a.setAttribute('data-host-url','https:&#x2F;&#x2F;analytics.eu.umami.is');document.body.appendChild(a)})()</script><script async data-host-url=https://analytics.eu.umami.is data-website-id=74344cd8-1e87-4c38-8acd-f96049b8f07e src=/js/imamu.js></script><script async data-goatcounter=https://Cyb0rG.goatcounter.com/count src=https://pwnverse.github.io/js/count.js></script><noscript><img src="https://Cyb0rG.goatcounter.com//count?p=/posts/leakguard/&t=Leakguard - HackTheVote 2020"></noscript><link title="Cyb0rG's Home" href=https://pwnverse.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://pwnverse.github.io/theme/light.css rel=stylesheet><link href=https://pwnverse.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><link href=https://pwnverse.github.io/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://pwnverse.github.io>Cyb0rG's Home</a><div class=socials><a class=social href=https://twitter.com/_Cyb0rG rel=me> <img alt=twitter src=/social_icons/twitter.svg> </a><a class=social href=https://github.com/PwnVerse/ rel=me> <img alt=github src=/social_icons/github.svg> </a></div></div><nav><a href=/posts style=margin-left:.7em>/posts</a><a href=/projects style=margin-left:.7em>/projects</a><a href=/about style=margin-left:.7em>/about</a> | <a href=javascript:void(0) id=dark-mode-toggle onclick=toggleTheme()> <img id=sun-icon src=/feather/sun.svg style=filter:invert(1)> <img id=moon-icon src=/feather/moon.svg> </a><script src=https://pwnverse.github.io/js/themetoggle.js></script></nav></header><main><article><div class=title><div class=page-header>Leakguard - HackTheVote 2020<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2020-10-30</time></div></div><section class=body><h1 id=tl-dr>tl;dr</h1><ul><li>overflow the <code>char</code> candle counter stored in the wax structure and trigger uaf.<li>Use the uaf to trigger double free and get shell.</ul><p><strong>Challenge Points:</strong> 385 <strong>Solves:</strong> 2<p>We had a great time this weekend playing this year's edition of HackTheVote. Since the CTF was conducted by RPISEC , nothing easy could be expected. I spent most of my time during the CTF on the challenge leakguard but we couldn't solve it during the CTF. But when I took sometime off and tried it , I finally solved it :).<h2 id=challenge-description>Challenge description</h2><p>We'd been given the challenge binary , the <strong>libc 2.27</strong> and a mysterious library which is being preloaded to run with the binary , the <strong>leakguard.so</strong>.<h2 id=initial-analysis>Initial analysis</h2><p>Let's have a quick look at <code>checksec</code>.<pre class=language-sh data-lang=sh style=background:#0f1419;color:#bfbab0><code class=language-sh data-lang=sh><span style=color:#ffb454>CANARY</span><span>    : disabled
</span><span style=color:#ffb454>FORTIFY</span><span>   : disabled
</span><span style=color:#ffb454>NX</span><span>        : ENABLED
</span><span style=color:#ffb454>PIE</span><span>       : ENABLED
</span><span style=color:#ffb454>RELRO</span><span>     : FULL
</span></code></pre><h2 id=reversing-the-shared-object>Reversing the shared object</h2><p>An interesting share object is shipped along with the binary executable. Here's what it does:<ul><li>Wrapper around <code>__GI_libc_write</code> internally called in every call to <code>puts</code>.<li>Reads data from <code>/proc/self/maps</code> which contains the virtual memory maps of the binary. (Pretty much <code>vmmap</code> of <code>gdb</code>)<li>Parse through the string which contains the data to be printed and check if anywhere , a valid memory address is present, if so , null the address number of bytes. It stops at null.</ul><h2 id=reversing-the-binary>Reversing the binary</h2><p>The <code>candles</code> binary has standard heap functions which are as follows :<ol><li><code>Add_wax</code></ol><ul><li>Check for an empty element in the bss <code>wax</code> table.<li>Subsequently, take input for choice of <code>oil</code> and <code>dye</code>.<li>Malloc a chunk of size <code>0x18</code> , then create a structure as follows -</ul><pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=color:#ff7733>struct </span><span style=color:#59c2ff>wax</span><span>{
</span><span>candle_count</span><span style=color:#bfbab0cc>;
</span><span style=color:#ff7733>long</span><span style=color:#f29668>*</span><span> ptr_to_oil_name</span><span style=color:#bfbab0cc>;
</span><span style=color:#ff7733>long</span><span style=color:#f29668>*</span><span> ptr_to_dye_name</span><span style=color:#bfbab0cc>;
</span><span>}</span><span style=color:#bfbab0cc>;
</span></code></pre><p>Initially , while adding a wax , the <code>candle_count</code> is set to <strong>1</strong>.<ol start=2><li><code>Remove_wax</code></ol><ul><li>Reduce the candle reference counter , check if it is 0 , and if so , free the wax structure ,else return without freeing the wax structure.<li>Null out the wax pointer in the <code>wax</code> bss table.</ul><ol start=3><li><code>Add candle</code></ol><ul><li>Take input of the index of wax to be associated with the candle.<li>Malloc a candle structure of size <code>0x18</code>.<li>Read <code>0x10</code> into the candle structure.<li>Increment the candle reference counter in the respective <code>wax</code> structure.</ul><p>The structure of candle structure is as follows :<pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=color:#ff7733>struct </span><span style=color:#59c2ff>candle </span><span>{
</span><span>
</span><span style=color:#ff7733>char</span><span> name[</span><span style=color:#f29718>0x10</span><span>]</span><span style=color:#bfbab0cc>;
</span><span style=color:#ff7733>unsigned char</span><span style=color:#f29668>*</span><span> reference_counter_ptr</span><span style=color:#bfbab0cc>;
</span><span>}</span><span style=color:#bfbab0cc>;
</span></code></pre><ol start=4><li><code>View candle</code></ol><ul><li>Print data of all candles but there's an additional check here. The <code>leakguard.so</code> comes into picture in the every call to <code>puts</code>. Since <code>puts</code> internally calls <code>__GI_libc_write</code> and <code>leakguard</code> is basically a wrapper around <code>__GI_libc_write</code> function.<li>If data contains a memory address , it gets nulled out :(.</ul><ol start=5><li><code>Remove_candle</code></ol><ul><li>Check if candle reference pointer is null or not , if null , reduce the candle count in the linked structure.<li>Check if the candle count linked to the wax structure is 0 or not , if 0 , free the wax structure <strong>without nulling out</strong> the wax pointer on the wax <code>bss</code> table.<li>Finally, free the <code>candle</code> and null out the candle pointer.</ul><p>Enough of reversing , let's get to some pwn business.<h2 id=vulnerability>Vulnerability</h2><p>During the CTF , we were able to find out the bug but there's a cool way by which it has to be triggered. The bug is that , if we give <code>0x10</code> bytes for the candle name, and try to print name , <code>puts</code> nulls out the <code>candle reference count</code> pointer. So you might ask , what is so useful about it? Well , remember in the <code>Remove candle</code> function , if this reference pointer is found to be nulled, we skip the whole part of decrementing the count altogether. We only free the candle pointer and null out it's subsequent bss entry.<h2 id=triggering-the-char-overflow>Triggering the char overflow</h2><p>Another important thing to note is that candle count is a <code>char</code> meaning it is bound to overflow. Now that we can prevent the decrement of candle count , we can very well trigger the overflow , all thanks to the leakguard :).<p>Once we trigger the overflow, the candle counter resets and finally we can free the <code>wax</code> pointer without nulling out it's subsequent memory. Hence we triggered a use after free.<p>But wait , we're missing out on something very important , the <strong>leaks</strong>.<h2 id=leaks>Leaks</h2><p>Even if leakguard does a good job by nulling a valid memory address , it cannot prevent partial memory leaks. Yes , you heard it right.<p>We can leak by overwriting the last 2 bytes of a heap address to make it an invalid memory address thus safely bypassing leakguard. To get proper leaks , we might have to resort to methods like binary search to fix the invalid addresses that we leak or in worst cases , bruteforce. So, what about libc??<p>Leak code segment address , then when we add a candle , the <strong>free wax structure</strong> is taken for allocation. Hence , we can change the contents of the structure. Recollect that the structure has pointers to the names of oil and dye. If we overwrite any of the pointer to the GOT address of <code>stdout</code> (which is there in bss) , we can leak libc in the subsequent printing of candle names.<h2 id=getting-that-shell>Getting that shell</h2><p>Now that you have a Use After Free , a libc leak and what's more, the provided libc is 2.27 hence no double free checks (phew!), Isn't that enough to pwn this binary now?<p>Once we get libc leak , we take the following steps to get shell :<ul><li>Overwrite the reference counter in the wax structure with <code>0x100</code> such that last byte is null.<li>Delete wax structure to free it.<li>Delete an intermediate candle.<li>Now delete a candle linked to the wax structure which was freed , since reference counter was 1 , it will become 0 and free the struct again.<li>Now add candle to get our free wax structure back.<li>Overwrite <code>fd</code> with <code>__free_hook</code>.<li>After another allocation , we get allocation at <code>__free_hook</code> itself, overwrite that with <code>system</code>.</ul><p>Wait, doing that will null the address of <code>system</code> since <code>__free_hook</code> is now a candle. Thinking a little , we can get allocation at <code>__free_hook - 1</code> , overwrite first byte with <code>\x00</code> so that we bypass the leakguard and hence overwrite <code>__free_hook</code> with system.<p>Add a candle with data as <code>/bin/sh\0</code> and free that candle to get shell.<h2 id=conclusion>Conclusion</h2><p>The idea of triggering a uaf with a char overflow is really novel. I had a great time solving the challenge. All in all ,awesome challenge , awesome idea , kudos to the author <strong>pernicious</strong> for such a good challenge and kudos to <strong>RPISEC</strong> for such a wonderful CTF.<p>Here's the exploit script - <a href=https://gist.github.com/PwnVerse/b455bc609f5f95e7808b4c0789f8ff13>Exploit</a></section></article></main></div>