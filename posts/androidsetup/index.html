<!doctype html><html class="dark light"><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Setting up debugging on Android
        
    </title><meta content="Setting up debugging on Android" property=og:title><link href=https://pwnverse.github.io/fonts.css rel=stylesheet><script>(function(){var a=document.createElement('script');a.setAttribute('src','/js/imamu.js');a.setAttribute('data-website-id','74344cd8-1e87-4c38-8acd-f96049b8f07e');a.setAttribute('data-host-url','https:&#x2F;&#x2F;analytics.eu.umami.is');document.body.appendChild(a)})()</script><script async data-host-url=https://analytics.eu.umami.is data-website-id=74344cd8-1e87-4c38-8acd-f96049b8f07e src=/js/imamu.js></script><script async data-goatcounter=https://Cyb0rG.goatcounter.com/count src=https://pwnverse.github.io/js/count.js></script><noscript><img src="https://Cyb0rG.goatcounter.com//count?p=/posts/androidsetup/&t=Setting up debugging on Android"></noscript><link title="Cyb0rG's Home" href=https://pwnverse.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://pwnverse.github.io/theme/light.css rel=stylesheet><link href=https://pwnverse.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><link href=https://pwnverse.github.io/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://pwnverse.github.io>Cyb0rG's Home</a><div class=socials><a class=social href=https://twitter.com/_Cyb0rG rel=me> <img alt=twitter src=/social_icons/twitter.svg> </a><a class=social href=https://github.com/PwnVerse/ rel=me> <img alt=github src=/social_icons/github.svg> </a></div></div><nav><a href=/posts style=margin-left:.7em>/posts</a><a href=/projects style=margin-left:.7em>/projects</a><a href=/about style=margin-left:.7em>/about</a> | <a href=javascript:void(0) id=dark-mode-toggle onclick=toggleTheme()> <img id=sun-icon src=/feather/sun.svg style=filter:invert(1)> <img id=moon-icon src=/feather/moon.svg> </a><script src=https://pwnverse.github.io/js/themetoggle.js></script></nav></header><main><article><div class=title><div class=page-header>Setting up debugging on Android<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2021-06-01</time></div></div><section class=body><p>I've been meaning to learn some android exploitation for quite sometime now. In this post , I propose to document the method of setting up a proper debugging environment (for self reference too) to debug android applications with the good old GDB.<h2 id=a-short-insight-into-the-android-system>A short insight into the Android system</h2><p>One might consider android to be an open source linux based system , although it's not completely true , android does have the linux kernel layer in it. The only similarity between android and linux is that they share a similar kernel but apart from that , everything else is mostly different. In linux on one hand , you can directly get root access with the <code>sudo</code> command , but that isn't the case (unless you've rooted your phone) on android. With root access to an android phone , you can basically access it's internal linux kernel layer and make modifications at the very heart of android , thus making it even more exciting to get your phone rooted. I have mentioned that android and linux share all their similarities in their kernel , which means they also have their differences.<h2 id=linux-kernel-vs-android-kernel>Linux Kernel vs Android Kernel</h2><p>There are quite a few functionalities which have been added to linux kernel to make it adept to be used as the android kernel.<h3 id=ipc-binder>IPC Binder</h3><p>Some apps attempt to implement IPC using traditional Linux techniques such as network sockets and shared files. However, now most apps use Android system functionality for IPC such as Intent, Binder or Messenger with a Service, and BroadcastReceiver. The Android IPC mechanisms allow you to verify the identity of the application connecting to your IPC and set security policy for each IPC mechanism.<p>There are 3 basic methods used for IPC on Android:<ol><li>AIDL<li>Messenger<li>Broadcast</ol><p>When do you know what to use?<p><img alt src=https://pwnverse.github.io/posts/androidsetup/./androidIPC.png><h2 id=ashmem-android-shared-memory>ASHMEM (Android Shared Memory)</h2><ul><li><p>Ashmem is an Anonymous Shared Memory system that adds interfaces so processes can share named blocks of memory. As an example, the system could use Ashmem to store icons, which multiple processes could then access when drawing their UI.</p><li><p>The advantage of Ashmem over traditional Linux shared memory is that it provides a means for the kernel to reclaim these shared memory blocks if they are not currently in use.</p><li><p>If a process then tries to access a shared memory block the kernel has freed, it will receive an error, and will then need to reallocate the block and reload the data.</p></ul><h2 id=process-memory-allocator-pmem>Process Memory Allocator (PMEM)</h2><p>This is used to manage large physically contiguous regions of memory shared between userspace and kernel drivers.<h2 id=ashmem-vs-pmem>Ashmem vs Pmem</h2><ul><li>Ashmem uses virtual memory whereas Pmem uses physically contiguous memory.<li>With Ashmem, we have <code>reference counted</code> objects that can be shared between multiple processes.<li>Pmem doesnt work that way because it needs to maintain physical to virtual mapping. This requires the process which allocates a pmem heap to hold the FD until all other references are dropped.</ul><h2 id=android-boot-process>Android Boot Process</h2><p>These are the steps in which Android Booting happens:<ol><li><code>Bootrom</code> , the write-protected flash rom which is embedded inside the processor's chip runs the very first code when an android phone is powered up.<li><code>Bootloader</code> is started by <code>Bootrom</code> which executes all boot specific setup ie, copies OS related programs into the main memory before firing up the kernel.<li><code>Kernel</code> starts up scheduling and loading drivers, setup cache , mounts all file systems, and finally executes something called <code>init</code> which is essentially the first process.<li><code>init</code> is the initial process which does things like mounting important directories like <code>/sys</code> , <code>/dev</code> and <code>/proc</code> and finally runs the <code>init.rc</code> script.<li>The <code>init.rc</code> is responsible for starting up important native daemons like the <code>Zygote process</code> ,<code>Service Manager</code>, <code>Media Server</code> etc.<li><code>Android Runtime</code> is started by the <code>init</code> process with <code>app_process</code> command which tells it to start the process virtual machine - <code>Art</code> or <code>Dalvik</code> and finally call the <code>zygote</code> processes' main function.</ol><p><img alt src=https://pwnverse.github.io/posts/androidsetup/./zygote.png><h2 id=a-little-more-about-zygote-process>A little more about Zygote Process</h2><p><code>Zygote</code> is a special android process that enables shared code across process VM in contrast to Java VM where each instance has it's own copy of all shared library class files and heap objects.<p>Zygote preloads all classes and resources which an app may potentially need at runtime into system's memory when it first starts. This technique speeds up loading of apps. After loading all app related stuff, zygote listens for connections on it's socket for requests of any new app starts. When a new app requests to start , zygote forks itself and launches the app. The <code>zygote</code> process serves as the <code>parent</code> to all android apps.<p>Zygote gets its forking feature from the Linux kernel implementation of <code>copy-on-write</code> technique. All processes starting from zygote use it's own copy. It doesnt actually copy anything , instead it maps pages of new process over those of the parent process and makes copies only when a new process writes on that page.<p><code>System Server</code> is the first process started by <code>Zygote</code>. After starting , it lives on as a separate process from it's parent. It starts initializing all system services.<h2 id=pre-requisites>Pre-requisites</h2><ul><li><p>Download and install latest version of Android Studio by following this wonderful <a href=https://linuxize.com/post/how-to-install-android-studio-on-ubuntu-18-04/>blog</a>.</p><li><p>For basic creating android virtual emulator , follow this <a href=https://developer.android.com/studio/run/managing-avds>blog</a>.</p></ul><p>Now that everything is ready and set , let's get to some business.<h2 id=making-system-writeable>Making system writeable</h2><p>To run <code>gdbserver</code> on our device , we need to first make the <code>/system</code> folder writeable, by default , it is read-only.<p>By default , even if we run <code>adb</code> as root , a couple of times , while trying to mount <code>/system</code> as writeable we're hit with the <code>/system not in /proc/mounts</code> as the <code>/system</code> partition is made <code>read only</code> in the very booting up of the emulator itself.<p>To fix that ,we fire up the emulator with <code>-writable system</code> flag , and then we can remount system as writeable with adb root.<p>To view list of active devices , run<pre class=language-sh data-lang=sh style=background:#0f1419;color:#bfbab0><code class=language-sh data-lang=sh><span style=color:#ffb454>adb-devices
</span></code></pre><p>The output should look something like this since we have just one device connected.<pre class=language-sh data-lang=sh style=background:#0f1419;color:#bfbab0><code class=language-sh data-lang=sh><span style=color:#ffb454>List</span><span> of devices attached
</span><span style=color:#ffb454>emulator-5554</span><span>	device
</span></code></pre><p>You can simply get into the device with<pre class=language-sh data-lang=sh style=background:#0f1419;color:#bfbab0><code class=language-sh data-lang=sh><span style=color:#ffb454>abd</span><span style=color:#f29718> -s</span><span> emulator-5554 shell
</span></code></pre><p>Note that <code>emulator-5554</code> is to be replaced with the name of the device we wish to connect to.<p>To get a list of all active emulators , navigate to the <code>/path/to/Android/Sdk/</code> and run -<pre class=language-sh data-lang=sh style=background:#0f1419;color:#bfbab0><code class=language-sh data-lang=sh><span style=font-style:italic;color:#39bae6>~</span><span style=color:#ffb454>/Android/Sdk/tools</span><span> ❯ ./emulator</span><span style=color:#f29718> -list-avds
</span><span>
</span><span style=color:#ffb454>Cyb0rG
</span><span style=color:#ffb454>Pixel_3a_API_30_x86
</span><span>
</span></code></pre><p>The output should be something similar.<p>Now , to fire up our emulator with writeable system , run<pre class=language-sh data-lang=sh style=background:#0f1419;color:#bfbab0><code class=language-sh data-lang=sh><span style=color:#ffb454>./emulator</span><span style=color:#f29718> -avd</span><span> Cyb0rG</span><span style=color:#f29718> -writable-system
</span></code></pre><p>Again , <code>Cyb0rG</code> should be replaced with the name of the desired avd.<p>After that, we run adb as root and remount it because it is by default mounted as <code>read-only</code> even if <code>-writable-system</code> is used.<pre class=language-sh data-lang=sh style=background:#0f1419;color:#bfbab0><code class=language-sh data-lang=sh><span style=color:#ffb454>adb</span><span> root
</span><span style=color:#ffb454>adb</span><span> remount
</span><span style=color:#ffb454>adb</span><span style=color:#f29718> -s</span><span> emulator-5554 shell
</span></code></pre><p>Finally, inside the device , mount the <code>/system</code> as read-write.<pre class=language-sh data-lang=sh style=background:#0f1419;color:#bfbab0><code class=language-sh data-lang=sh><span style=color:#ffb454>mount</span><span style=color:#f29718> -o</span><span> rw,remount /system
</span><span style=color:#ffb454>mount</span><span style=color:#f29718> -o</span><span> rw,remount /
</span></code></pre><h2 id=setting-up-the-gdbserver>Setting up the gdbserver</h2><p>Verify the architecture of your connected device with <code>uname -m</code> inside the adb shell.<p>Navigate to the <code>ndk</code> folder which should ideally be located in the <code>Sdk</code> folder itself. Once there , you will find a <code>prebuilt</code> folder in which we find <code>gdbserver</code> for various architectures.<p>Since I'm running the emulator on x86 , this is the path to gdbserver in my machine.<pre class=language-sh data-lang=sh style=background:#0f1419;color:#bfbab0><code class=language-sh data-lang=sh><span style=font-style:italic;color:#39bae6>~</span><span style=color:#ffb454>/Android/Sdk/ndk/22.1.7171670/prebuilt/android-x86_64/gdbserver
</span></code></pre><p>Once here, we push <code>gdbserver</code> into our device with <code>adb push gdbserver /system/bin</code>.<p>Now that we have pushed <code>gdbserver</code> , we can easily attach to any process by it's process id. We get the <code>pid</code> of a process with <code>ps aux | grep &LTprocess_name></code>.<pre class=language-sh data-lang=sh style=background:#0f1419;color:#bfbab0><code class=language-sh data-lang=sh><span style=color:#ffb454>gdbserver</span><span> :8888</span><span style=color:#f29718> --attach</span><span> 2741
</span></code></pre><p>Replace <code>2741</code> with the <code>pid</code> of the process you wish to debug.<p>After that , we port forward from adb shell to our host machine so that we can debug from the comforts of our local machine.<pre style=background:#0f1419;color:#bfbab0><code><span>adb forward tcp:8888 tcp:8888
</span></code></pre><p>Now, all that is left is to fire up gdb , and run <code>target remote :8888</code>.<h2 id=conclusion>Conclusion</h2><p>That's all there is to setup gdb to debug native android applications.</section></article></main></div>