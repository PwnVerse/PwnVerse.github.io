<!doctype html><html class="dark light"><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Kstack seccon 2020
        
    </title><meta content="Kstack seccon 2020" property=og:title><link href=https://pwnverse.github.io/fonts.css rel=stylesheet><script>(function(){var a=document.createElement('script');a.setAttribute('src','/js/imamu.js');a.setAttribute('data-website-id','74344cd8-1e87-4c38-8acd-f96049b8f07e');a.setAttribute('data-host-url','https:&#x2F;&#x2F;analytics.eu.umami.is');document.body.appendChild(a)})()</script><script async data-host-url=https://analytics.eu.umami.is data-website-id=74344cd8-1e87-4c38-8acd-f96049b8f07e src=/js/imamu.js></script><script async data-goatcounter=https://Cyb0rG.goatcounter.com/count src=https://pwnverse.github.io/js/count.js></script><noscript><img src="https://Cyb0rG.goatcounter.com//count?p=/posts/kstack/&t=Kstack seccon 2020"></noscript><link title="Cyb0rG's Home" href=https://pwnverse.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://pwnverse.github.io/theme/light.css rel=stylesheet><link href=https://pwnverse.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><link href=https://pwnverse.github.io/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://pwnverse.github.io>Cyb0rG's Home</a><div class=socials><a class=social href=https://twitter.com/_Cyb0rG rel=me> <img alt=twitter src=/social_icons/twitter.svg> </a><a class=social href=https://github.com/PwnVerse/ rel=me> <img alt=github src=/social_icons/github.svg> </a></div></div><nav><a href=/posts style=margin-left:.7em>/posts</a><a href=/projects style=margin-left:.7em>/projects</a><a href=/about style=margin-left:.7em>/about</a> | <a href=javascript:void(0) id=dark-mode-toggle onclick=toggleTheme()> <img id=sun-icon src=/feather/sun.svg style=filter:invert(1)> <img id=moon-icon src=/feather/moon.svg> </a><script src=https://pwnverse.github.io/js/themetoggle.js></script></nav></header><main><article><div class=title><div class=page-header>Kstack seccon 2020<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2021-03-22</time></div></div><section class=body><p>So this week, I came across yet another kernel exploitation challenge and the reason I'm documenting the writeup (even if there're plenty of better ones available) is simply because I had to use multiple race conditions to get kernel instruction pointer.<h1 id=tl-dr>tl;dr</h1><ul><li>Abuse the <code>race condition</code> to leak kernel base.<li>Resuing the race condition , get write on <code>seq_operations</code> structure.<li>Write to <code>fd</code> of the <code>seq</code> structure using <code>setxattr</code>.<li>Pivot stack to userspace address since there is no SMAP.<li>Standard <code>commit_creds(prepare_kernel_creds(0))</code> ROP.</ul><h1 id=setting-up-the-debug-environment>Setting up the debug environment</h1><ul><li>Unpack <code>rootfs.cpio</code> with</ul><pre class=language-sh data-lang=sh style=background:#0f1419;color:#bfbab0><code class=language-sh data-lang=sh><span style=color:#ffb454>mkdir</span><span> rootfs </span><span style=color:#f29668>&& </span><span style=color:#f07178>cd</span><span> rootfs
</span><span style=color:#ffb454>sudo</span><span> su
</span><span style=color:#ffb454>cat</span><span> ../rootfs.cpio </span><span style=color:#f29668>| </span><span style=color:#ffb454>cpio</span><span style=color:#f29718> --extract
</span></code></pre><ul><li>Edit the <code>init</code> script , comment out the <code>echo 1</code> happening on <code>kptr_restrict</code> and <code>dmesg_restrict</code>.<li>Add the <code>setsid /bin/cttyhack setuidgid 0 /bin/sh</code> to get root for debugging.<li>Disable <code>kaslr</code> in the <code>runner</code> script.</ul><p>Use this script to compile and copy exploit automatically in later stages.<pre class=language-sh data-lang=sh style=background:#0f1419;color:#bfbab0><code class=language-sh data-lang=sh><span style=font-style:italic;color:#5c6773>#!/bin/bash
</span><span>
</span><span style=color:#ffb454>gcc</span><span style=color:#f29718> -o</span><span> exp exp.c</span><span style=color:#f29718> --static -lpthread
</span><span style=color:#ffb454>cp</span><span> exp rootfs
</span><span style=color:#f07178>cd</span><span> rootfs
</span><span style=color:#ffb454>find</span><span> . </span><span style=color:#f29668>| </span><span style=color:#ffb454>cpio</span><span style=color:#f29718> -o -H</span><span> newc </span><span style=color:#f29668>></span><span> ../rootfs.cpio
</span><span style=color:#f07178>cd</span><span> ..
</span></code></pre><h1 id=reversing>Reversing</h1><p>The author was benevolent enough to provide us with a self explanatory source code.<p>For the sake of brevity , we'll just look into the important part of it.<pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=color:#ff7733>static long </span><span style=color:#ffb454>proc_ioctl</span><span>(</span><span style=color:#ff7733>struct</span><span> file </span><span style=color:#f29668>*</span><span style=color:#f29718>filp</span><span style=color:#bfbab0cc>, </span><span style=color:#ff7733>unsigned int </span><span style=color:#f29718>cmd</span><span style=color:#bfbab0cc>, </span><span style=color:#ff7733>unsigned long </span><span style=color:#f29718>arg</span><span>)
</span><span>{
</span><span>  Element </span><span style=color:#f29668>*</span><span>tmp</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668>*</span><span>prev</span><span style=color:#bfbab0cc>;
</span><span>  </span><span style=color:#ff7733>int</span><span> pid </span><span style=color:#f29668>= </span><span style=color:#ffb454>task_tgid_nr</span><span>(current)</span><span style=color:#bfbab0cc>;
</span><span>  </span><span style=color:#ff7733>switch</span><span>(cmd) {
</span><span>  </span><span style=color:#ff7733>case</span><span> CMD_PUSH</span><span style=color:#bfbab0cc>:
</span><span>    tmp </span><span style=color:#f29668>= </span><span style=color:#ffb454>kmalloc</span><span>(</span><span style=color:#ff7733>sizeof</span><span>(Element)</span><span style=color:#bfbab0cc>,</span><span> GFP_KERNEL)</span><span style=color:#bfbab0cc>;
</span><span>    tmp</span><span style=color:#f29668>-></span><span>owner </span><span style=color:#f29668>=</span><span> pid</span><span style=color:#bfbab0cc>;
</span><span>    tmp</span><span style=color:#f29668>-></span><span>fd </span><span style=color:#f29668>=</span><span> head</span><span style=color:#bfbab0cc>;
</span><span>    head </span><span style=color:#f29668>=</span><span> tmp</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>if </span><span>(</span><span style=color:#ffb454>copy_from_user</span><span>((</span><span style=color:#ff7733>void</span><span style=color:#f29668>*</span><span>)</span><span style=color:#f29668>&</span><span>tmp</span><span style=color:#f29668>-></span><span>value</span><span style=color:#bfbab0cc>, </span><span>(</span><span style=color:#ff7733>void</span><span style=color:#f29668>*</span><span>)arg</span><span style=color:#bfbab0cc>, </span><span style=color:#ff7733>sizeof</span><span>(</span><span style=color:#ff7733>unsigned long</span><span>))) {
</span><span>      head </span><span style=color:#f29668>=</span><span> tmp</span><span style=color:#f29668>-></span><span>fd</span><span style=color:#bfbab0cc>;
</span><span>      </span><span style=color:#ffb454>kfree</span><span>(tmp)</span><span style=color:#bfbab0cc>;
</span><span>      </span><span style=color:#ff7733>return </span><span style=color:#f29668>-</span><span>EINVAL</span><span style=color:#bfbab0cc>;
</span><span>    }
</span><span>    </span><span style=color:#ff7733>break</span><span style=color:#bfbab0cc>;
</span><span>  </span><span style=color:#ff7733>case</span><span> CMD_POP</span><span style=color:#bfbab0cc>:
</span><span>    </span><span style=color:#ff7733>for</span><span>(tmp </span><span style=color:#f29668>=</span><span> head</span><span style=color:#bfbab0cc>,</span><span> prev </span><span style=color:#f29668>= </span><span style=color:#f29718>NULL</span><span style=color:#bfbab0cc>;</span><span> tmp </span><span style=color:#f29668>!= </span><span style=color:#f29718>NULL</span><span style=color:#bfbab0cc>;</span><span> prev </span><span style=color:#f29668>=</span><span> tmp</span><span style=color:#bfbab0cc>,</span><span> tmp </span><span style=color:#f29668>=</span><span> tmp</span><span style=color:#f29668>-></span><span>fd) {
</span><span>      </span><span style=color:#ff7733>if </span><span>(tmp</span><span style=color:#f29668>-></span><span>owner </span><span style=color:#f29668>==</span><span> pid) {
</span><span>        </span><span style=color:#ff7733>if </span><span>(</span><span style=color:#ffb454>copy_to_user</span><span>((</span><span style=color:#ff7733>void</span><span style=color:#f29668>*</span><span>)arg</span><span style=color:#bfbab0cc>, </span><span>(</span><span style=color:#ff7733>void</span><span style=color:#f29668>*</span><span>)</span><span style=color:#f29668>&</span><span>tmp</span><span style=color:#f29668>-></span><span>value</span><span style=color:#bfbab0cc>, </span><span style=color:#ff7733>sizeof</span><span>(</span><span style=color:#ff7733>unsigned long</span><span>)))
</span><span>          </span><span style=color:#ff7733>return </span><span style=color:#f29668>-</span><span>EINVAL</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#ff7733>if </span><span>(prev) {
</span><span>          prev</span><span style=color:#f29668>-></span><span>fd </span><span style=color:#f29668>=</span><span> tmp</span><span style=color:#f29668>-></span><span>fd</span><span style=color:#bfbab0cc>;
</span><span>        } </span><span style=color:#ff7733>else </span><span>{
</span><span>          head </span><span style=color:#f29668>=</span><span> tmp</span><span style=color:#f29668>-></span><span>fd</span><span style=color:#bfbab0cc>;
</span><span>        }
</span><span>        </span><span style=color:#ffb454>kfree</span><span>(tmp)</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#ff7733>break</span><span style=color:#bfbab0cc>;
</span><span>      }
</span><span>      </span><span style=color:#ff7733>if </span><span>(tmp</span><span style=color:#f29668>-></span><span>fd </span><span style=color:#f29668>== </span><span style=color:#f29718>NULL</span><span>) </span><span style=color:#ff7733>return </span><span style=color:#f29668>-</span><span>EINVAL</span><span style=color:#bfbab0cc>;
</span><span>    }
</span><span>    </span><span style=color:#ff7733>break</span><span style=color:#bfbab0cc>;
</span><span>  }
</span><span>  </span><span style=color:#ff7733>return </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;
</span><span>}
</span></code></pre><ul><li>We have the <code>push</code> and <code>pop</code> operations.</ul><h3 id=push>Push</h3><ul><li>The <code>push</code> operation first <code>kmalloc</code>s a chunk of <code>8</code> bytes.<li>It then tries to <code>copy_from_user</code> 8 bytes of data from userspace.<li>If <code>copy_from_user</code> fails , it <code>free</code>s the chunk that was allocated.</ul><h3 id=pop>Pop</h3><ul><li>Try to <code>copy_to_user</code> 8 bytes of <code>tmp->value</code>.<li>If it succeeds , the <code>head</code> pointer is appropriately set and finally <code>free</code> is called on the chunk on which <code>pop</code> was requested.</ul><h1 id=bug>Bug</h1><p>There's no implementation bug as such in this small program , but if you see , the <code>ioctl</code> operations dont have any locks and hence we can request multiple operations at once using two threads.<h1 id=exploit>Exploit</h1><p>The idea is that we execute a multi-stage exploit to successively leak and get write on a useful structure. So how do we go about doing this?<p>By making use of the race condition, we can actually invoke a double free.<ul><li>If we call a <code>pop</code> operation on an untouched memory region, we can trigger a pagefault in <code>copy_to_user</code>, and this opens up a race window for exploitation.<li>So , if we can monitor this untouched memory region from another thread, we can very well handle this page fault and do some more operations until the page fault is fixed and control is transferred back to <code>pop</code> function.</ul><pre style=background:#0f1419;color:#bfbab0><code><span>                                            ┌───────────────────────────────────┐     ┌─────────────────────┐
</span><span>                                            │                                   │     │                     │
</span><span>                            ┌──────────────►│ page_fault   -> call pop on valid ├────►│ calls free(chunk)   │
</span><span>                            │               │   handler            memory       │     │ after copy_from_user│
</span><span>                            │               │                                   │     │                     │
</span><span>                       ┌────┴──────┐        └─────────────────────────────┬─────┘     └────┬────────────────┘
</span><span>                       │ page_fault│                                      │                │
</span><span>                       │           │                                      │  return back   │
</span><span>                       └───────────┘                                      └───────┬────────┘
</span><span>                             ▲                                                    │
</span><span>                             │                                                    │
</span><span>                             │                                                    │ page_fault handler returns 
</span><span>┌───────────────┐    ┌───────┴─────────┐                                  ┌───────▼──────────────┐
</span><span>│               │    │                 │                                  │                      │
</span><span>│pop(race_page) ├───►│  copy_from_user ├─────────────────────────────────►│   free(chunk)        │
</span><span>│               │    │                 │                                  │                      │
</span><span>└───────────────┘    │                 │                                  │                      │
</span><span>                     └─────────────────┘                                  └──────────────────────┘
</span><span>
</span></code></pre><p>To manage page faults from userspcace , the kernel provides us with <code>userfaultfd</code>. With <code>userfaultfd</code>, we can monitor an mmaped page from another thread and handle our page faults.<h1 id=going-for-leaks>Going for leaks</h1><p>The issue here is that, copy_from_user and copy_to_user write and read from the next 8 bytes of a chunk , so we can't really leak normally by getting allocation on a useful structure. Another reason is that, <code>copy_from</code> functions will null out memory. So, our ultimate option is to leak memory via race condition.<p>To do so,<ul><li>open and close a couple of <code>/proc/self/stat</code> , nothing but our <code>seq_operations</code> structure. This will make sure our next <code>kmalloc</code> allocates from a freed structure which has kernel pointers.<li>Initialize <code>userfaultfd</code> on our race page , in this case <code>0xf00d000</code>.<li><code>push</code> a value and call pop on our race page which will cause a page fault in <code>copy_from_user</code>.<li>In the fault handler , we immediately call <code>pop</code> on a valid address and successfully leak kernel pointer.</ul><h1 id=double-free-to-rip>Double free to RIP</h1><p>After we leak , we can find a suitable stack pivot gadget from the kernel. Similarly , we can now cause a double free in heap , and using that, we get overlapping of <code>seq_operations</code> and <code>setxattr</code> structures. The reason for chosing this overlap is that , <code>setxattr</code> lets us write 8 bytes to the fd of our chunk with it's <code>size</code> field.<p>So , using this , we can overwrite the kernel function pointer at the fd of our <code>seq_operations</code> structure and get RIP by calling <code>read</code> on the file descriptor of the opened structure.<h2 id=short-info>Short Info</h2><p>I had a good time (with all due pun intended) debugging the kernel and source code auditing of <code>setxattr</code> as I had repeated kernel panics due to a silly mistake I had made in my script. But this debugging led me to another fruitful result.<p>Internally, <code>setxattr</code> calls <code>kmalloc</code> and <code>kfree</code> in the end after setting the fd. The <code>fd</code> pointer actually gets overwritten with a kernel executable address which points very close to a <code>ret</code> instruction. So , what happens is , when read is called on the fd , it actually executes the fd pointer first , but it returns immediately and then executes <code>fd + 0x18</code> pointer. This is the offset which actually gives us the RIP control.<p>Hence , the idea is to spray our gadget all over the <code>seq_operations</code> structure.<h1 id=conclusion>Conclusion</h1><p>The idea of the challenge was something different from a normal race condition. Kudos to the author for such a cool challenge.<p><a href=https://gist.github.com/PwnVerse/a0ebb13bec35b867b70d0a2a49e91f22>Here</a> is the complete exploit.</section></article></main></div>