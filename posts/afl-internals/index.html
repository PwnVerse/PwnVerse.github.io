<!doctype html><html class="dark light"><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         AFL Internals
        
    </title><meta content="AFL Internals" property=og:title><link href=https://pwnverse.github.io/fonts.css rel=stylesheet><script>(function(){var a=document.createElement('script');a.setAttribute('src','/js/imamu.js');a.setAttribute('data-website-id','74344cd8-1e87-4c38-8acd-f96049b8f07e');a.setAttribute('data-host-url','https:&#x2F;&#x2F;analytics.eu.umami.is');document.body.appendChild(a)})()</script><script async data-host-url=https://analytics.eu.umami.is data-website-id=74344cd8-1e87-4c38-8acd-f96049b8f07e src=/js/imamu.js></script><script async data-goatcounter=https://Cyb0rG.goatcounter.com/count src=https://pwnverse.github.io/js/count.js></script><noscript><img src="https://Cyb0rG.goatcounter.com//count?p=/posts/afl-internals/&t=AFL Internals"></noscript><link title="Cyb0rG's Home" href=https://pwnverse.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://pwnverse.github.io/theme/light.css rel=stylesheet><link href=https://pwnverse.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><link href=https://pwnverse.github.io/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://pwnverse.github.io>Cyb0rG's Home</a><div class=socials><a class=social href=https://twitter.com/_Cyb0rG rel=me> <img alt=twitter src=/social_icons/twitter.svg> </a><a class=social href=https://github.com/PwnVerse/ rel=me> <img alt=github src=/social_icons/github.svg> </a></div></div><nav><a href=/posts style=margin-left:.7em>/posts</a><a href=/projects style=margin-left:.7em>/projects</a><a href=/about style=margin-left:.7em>/about</a> | <a href=javascript:void(0) id=dark-mode-toggle onclick=toggleTheme()> <img id=sun-icon src=/feather/sun.svg style=filter:invert(1)> <img id=moon-icon src=/feather/moon.svg> </a><script src=https://pwnverse.github.io/js/themetoggle.js></script></nav></header><main><article><div class=title><div class=page-header>AFL Internals<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2021-11-11</time></div></div><section class=body><p>I've been using AFL for quite sometime now, but really wanted to know how it works internally. This blog post is solely meant as a means of documentation for whatever I've learnt and I'd be glad if it helps someone else too.<h2 id=the-background>The background</h2><p>AFL is some of the most commonly used fuzzers in the wild. It is a coverage guided fuzzer. I'm not going to discuss what AFL is good at, you can always refer to it's <a href=https://github.com/AFLplusplus/AFLplusplus>source</a> for knowing that.<p>We know that AFL is a coverage guided fuzzer , but how exactly does AFL collect coverage?<h2 id=coverage-measurements>Coverage measurements</h2><p>When you use <code>afl-gcc</code> or an instrumentation compiler of that sort , several instrumentation functions are added to the compiled executable for capturing coverage related information. More specifically, the instrumentation injected into compiled programs captures branch (edge) coverage, along with coarse branch-taken hit counts.<p>To understand this better , here's the pseudo code in action for capturing branch coverage -<pre style=background:#0f1419;color:#bfbab0><code><span>cur_location = &LTCOMPILE_TIME_RANDOM>;
</span><span>shared_mem[cur_location ^ prev_location]++; 
</span><span>prev_location = cur_location >> 1;
</span></code></pre><p>Let's break this down to understand it better -<ul><li><p>The <code>cur_location</code> is generated randomly. The reason is to simplify the process of linking complex projects. Another reason why this is needed is that the output of XOR operations which follow need to be distributed uniformly. You might be wondering why this is needed , we will see more about this in a bit.</p><li><p>The <code>shared_mem</code> array is a 64 KB shared memory region passed to the instrumentation binary by the caller. Every byte set in the output map can be thought of as a hit for a particular branch (branch_src , branch_dst) tuple.</p><li><p>The <code>cur_location ^ prev_location</code> acts as a unique index to the shared mem responsible for unique hits.</p><li><p>The right shift operation in the last line is to preserve the directionality of tuples. Without this , A ^ B would be indistinguishable from B ^ A.</p></ul><p>By now you might be wondering if there's a chance for the XOR operation to return the same result over a certain period or in more simpler terms , collision. Keeping this in mind, developers of AFL used the <code>COMPILE_TIME_RANDOM</code> to almost make sure that <code>cur_location</code> is unique.<p>Despite of this certainity that the random time provides , there's still a chance of collisions. Here's where the size of the map comes to rescue and is chosen so that collisions are sporadic with almost all of the intended targets, which usually sport between 2k and 10k discoverable branch points.<p>Moreover , the size of the map is also small enough to fit into L2 cache which allows the the map to be analyzed in a matter of microseconds on the receiving end.<p>This form of coverage provides considerably more insight into the execution path of the program than simple block coverage.<p>So now that we know how AFL deals with coverage information , we should now look forward to understanding how AFL uses this coverage information to detect new behaviours.<h2 id=detecting-new-behaviors>Detecting new behaviors</h2><p>The idea is simple, AFL maintains a global map of <code>&LTbranch_src , branch_dst></code> tuples which can can be rapidly compared with individual traces and updated in just a couple of instructions and a simple loop.<p>When a certain input produces an execution trace containing new tuples (essentially a new code path) , the input file is preserved and routed for additional processing later on. As expected , inputs which do not generate newer tupes are discarded even if the overall control flow sequence is unique. This allows for a more fine-grained and long-term exploration of program state all the while not having to perform any computationally intensive tasks.<p>To better understand how the algorithm works , lets have a look at the following execution traces -<pre style=background:#0f1419;color:#bfbab0><code><span>  #1: A -> B -> C -> D -> E
</span><span>  #2: A -> B -> C -> A -> E
</span></code></pre><p>The <code>#2</code> trace is considered unique due to the presence of new tuples (CA, AE)<p>But now that <code>#2</code> is processed ,something like the following <strong>wont be recognized as unique</strong> -<pre style=background:#0f1419;color:#bfbab0><code><span>#3: A -> B -> C -> A -> B -> C -> A -> B -> C -> D -> E
</span></code></pre><p>Apart from new tuples , AFL also considers coarse magnitude count for tuple hit rate. This count is divided into several buckets -<pre style=background:#0f1419;color:#bfbab0><code><span>1, 2, 3, 4-7, 8-15, 16-31, 32-127, 128+
</span></code></pre><p>Changes within a bucket's range are ignored but transition from one bucket to another is flagged as an interesting change in program's control flow.<p>This hit count behaviour can tell us alot more about potentially interesting control flow changes. As you can guess by now , all these algorithms running under the hoodf of AFL are fairly memory expensive.<p>Now that we've seen how AFL detects new behaviours , let us also see how AFL optimizes it's fuzzing efforts.<h2 id=culling-the-corpus>Culling the corpus</h2><p>AFL periodically re-evaluates the input queue using a fast algorithm that selects a smaller subset of test cases that still cover every tuple seen so far and whose characterstics make them particularly favourable to the tool.<p>The algorithm works by assigning every queue entry a score proportional to it's execution policy and file size and then selecting lowest-scoring. The tuples are then processed as follows -<ul><li>Find next tuple not yet in temporary working set.<li>Locate the winning queue for this tuple.<li>Register all tuples present in that entry's trace in working set.<li>Repeat the above steps if there are any missing tuples in the set.</ul><p>So what happens with the non-favoured entries? They're discarded? Well , apparently not. AFL doesn't discard non-favoured inputs, but they are skipped with varying probabilities when encountered in the queue :<ul><li><p>If there are new yet-to-be-fuzzed favourites in the queue, all non-favoured entires are discarded.</p><li><p>If no new favourites found :</p> <ol><li>If current non-favoured entry was fuzzed before, it will be skipped 95% of times.<li>If it hasn't gone through any fuzzing rounds yet, the odds of skipping drop down to 75%.</ol></ul><p>Now that we're aware of how the input corpus is selected curatively, we must also see how AFL manages inputs with large and varying sizes.<h2 id=trimming-the-input-files>Trimming the input files</h2><p>As you can probably guess , file size has a drastic impact over the overall performence of the fuzzer. This is simply because large files make target binary slower and also because they reduce the likelihood that a mutation would touch important format control structures , rather than any redundant data blocks.<p>Luckily for us, the instrumentation feedback provides a simple and robust way to automatically trim down input files while ensuring that changes made to the files have no impact on execution path.<p>The built-in trimmer attempts to sequentially remove blocks of data with variable length. Basically , <strong>any deletion which doesnt effect the checksum of the trace is commited to the disk.</strong><p>There's also the standalone <code>afl-tmin</code> which provides more exhaustive iterative algorithm to perform normalization on trimmed files.<p>The actual minimization technique is :<ol><li>Attempt to zero large blocks of data with large stepovers.<li>Perform a block detection pass with decreasing block sizes and stepovers - more like binary search.<li>Perform alphabet normalization by counting unique characters and trying to bulk-replace each with zero value.</ol><p>Now that we have seen how AFL trims and optimizes input files for removing redundant data blocks , we should also have a look at how AFL chooses it's fuzzing strategies.<h2 id=fuzzing-strategies>Fuzzing strategies</h2><p>Early on during fuzzing, AFL chooses a fairly deterministic approach, and then progresses to random stacked modifications and test case splicing. The early stages include the following strategies :<ul><li>Sequential bit flips with varying lengths.<li>Sequential additions and subtraction of small integers.<li>Sequential insertions of known interesting integers (negetive numbers, INT_MAX)</ul><p>The non-deterministic approaches include stacked bit flips , insertions , deletions , arithmetics and splicing of different test cases.<h2 id=fork-server>Fork server</h2><p>To improve performence, AFL uses something known as fork-server , where the fuzzed process goes through <code>execve</code> , and doing all the linking and initializing only once ; after that it is cloned from stopped process image by leveraging <code>copy-on-write</code>.<p>The way fork-server works is that it simply stops at the first instrumented function to await commands from <code>afl-fuzz</code>.</section></article></main></div>