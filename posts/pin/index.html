<!doctype html><html class="dark light"><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Short Notes on Internals Of the Intel PIN
        
    </title><meta content="Short Notes on Internals Of the Intel PIN" property=og:title><link href=https://pwnverse.github.io/fonts.css rel=stylesheet><script>(function(){var a=document.createElement('script');a.setAttribute('src','/js/imamu.js');a.setAttribute('data-website-id','74344cd8-1e87-4c38-8acd-f96049b8f07e');a.setAttribute('data-host-url','https:&#x2F;&#x2F;analytics.eu.umami.is');document.body.appendChild(a)})()</script><script async data-host-url=https://analytics.eu.umami.is data-website-id=74344cd8-1e87-4c38-8acd-f96049b8f07e src=/js/imamu.js></script><script async data-goatcounter=https://Cyb0rG.goatcounter.com/count src=https://pwnverse.github.io/js/count.js></script><noscript><img src="https://Cyb0rG.goatcounter.com//count?p=/posts/pin/&t=Short Notes on Internals Of the Intel PIN"></noscript><link title="Cyb0rG's Home" href=https://pwnverse.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://pwnverse.github.io/theme/light.css rel=stylesheet><link href=https://pwnverse.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><link href=https://pwnverse.github.io/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://pwnverse.github.io>Cyb0rG's Home</a><div class=socials><a class=social href=https://twitter.com/_Cyb0rG rel=me> <img alt=twitter src=/social_icons/twitter.svg> </a><a class=social href=https://github.com/PwnVerse/ rel=me> <img alt=github src=/social_icons/github.svg> </a></div></div><nav><a href=/posts style=margin-left:.7em>/posts</a><a href=/projects style=margin-left:.7em>/projects</a><a href=/about style=margin-left:.7em>/about</a> | <a href=javascript:void(0) id=dark-mode-toggle onclick=toggleTheme()> <img id=sun-icon src=/feather/sun.svg style=filter:invert(1)> <img id=moon-icon src=/feather/moon.svg> </a><script src=https://pwnverse.github.io/js/themetoggle.js></script></nav></header><main><article><div class=title><div class=page-header>Short Notes on Internals Of the Intel PIN<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2020-06-10</time></div></div><section class=body><p>I had a little introduction to a bit of formal Binary Instrumentation and was very fascinated by how PIN works in Dynamic Binary Instrumentation.<p>In this post , I would like to discuss a few internals of how PIN works.<h2 id=tl-dr-of-what-exactly-is-pin>TL;DR OF WHAT EXACTLY IS PIN</h2><p><strong>Dynamic Binary Instrumentation</strong> [DBI] Engines monitor binaries as they execute and instrument the instruction stream, they dont require disassembly or binary rewriting like <strong>Static Binary Instrumentation</strong> [SBI] which makes them <strong>less</strong> error-prone.<p>Pin is one such famous DBI Engine.<p>Before heading on , let us know about the architecture of a DBI system.<h3 id=architecture-of-a-dbi-system>Architecture Of A DBI System</h3><p>The DBI engine exposes an <strong>API</strong> that lets programmers write <em>user-defined DBI tools</em> that specify which code should be instrumented and how.<ul><li>Before DBI engine starts the main application process, it allows the DBI tool to initialize itself.<li>Next , the function tells DBI engine that it's done initializing and ready to start the app.</ul><p>The DBI engine never runs the application process directly but instead runs code in a <a href="https://www.baeldung.com/jvm-code-cache#:~:text=What%20Is%20the%20Code%20Cache,of%20the%20code%20cache%20area.">code cache</a> that contains all the instrumented code. {: .notice}<ul><li>After instrumenting the code , the DBI engine compiles it with a <strong>Just-In Time [JIT]</strong> compiler which re-optimizes the code and stores the compiled code in code cache.</ul><blockquote><p>Note that unlike most compilers , the JIT compiler in DBI engine doesn't translate the code into a different language; it just compiles from native machine code to native machine code.</blockquote><p>Once compiled code is stored and used from code cache and doesn't have to be recompiled again.<ul><li><p>DBI engines like <strong>PIN</strong> , <strong>DynamoRIO</strong> , <strong>Dyninst</strong> and <strong>PEBIL</strong> reduce runtime overhead by rewriting control-flow instructions when possible , so they jump directly , to the next block in the code cache without any intervention of the DBI system.</p><li><p>When the direct jumps to code cache are not possible , the rewritten instructions return control to the DBI engine so that it can prepare and start the next code chunk.</p></ul><p>While most instructions run natively in the code cache , the DBI engine may emulate some instructions instead of running them directly. <strong>PIN</strong> does this exquisitely for system calls like <strong>execve</strong> that require special handling by DBI engine. {: .notice}<ul><li>The instrumented code contains <strong>Callbacks</strong> to functions in the DBI tool that observe or modify the code's behaviour.</ul><p>Now that we're familiar with the workings DBI engine , let's get our hands dirty with <strong>PIN internals</strong>.<h2 id=pin-internals>PIN INTERNALS</h2><p>Pin fetches and JIT-compiles at <strong>trace granularity</strong> , a basic block-like abstraction that can be entered only at top but may contain multiple exits, unlike regular basic blocks.<h3 id=trace>TRACE</h3><p>Pin defines a trace as a straight-line instruction sequence that ends when it hits an unconditional control transfer or reaches a predefined maximum length or number of conditional control-flow instructions.<blockquote><p>Although PIN always JIT-compiles code at trace granularity , it allows you to instrument code at many granularities , including <strong>instruction</strong>, <strong>basic block</strong> , <strong>trace</strong> , <strong>function</strong> and <strong>complete executable[image]</strong>.</blockquote><p>The DBI tools we implement with PIN are called <strong>Pintools</strong> , which are shared libraries that we write with in C/C++ using Pin API.<p>The Pintool consists of 2 components.<ol><li><p><strong>Instrumentation Routines</strong></p> <ul><li>Tell which Pin which instrumentation code to add where.<li>These functions run only the first time Pin encounters a particular piece of code that's not yet instrumented.</ul><li><p><strong>Analysis Routines</strong></p> <ul><li>To instrument code , the instrumentation routines install <strong>callbacks</strong> to analysis routines.</ul></ol><p><strong>CallBacks</strong> contain the actual instrumentation code and are called everytime an instrumented code sequence runs. {: .notice}<p>Well, now it's time to play around with Pin. I came across a practical example to learn a bit more on the internals of PIN. Let's see what that is.<h2 id=profiling-with-pin>PROFILING WITH PIN</h2><ul><li><p>The profiling tool records statistics about a program's execution to help optimize that program.</p><li><p>It counts the number of executed instructions and the no. of times basic blocks , functions and syscalls are involved.</p><li><p>Pintools can implement tool-specific command line options , which are called <strong>knobs</strong> in pin's slang.</p><li><p>There is a dedicated class called <strong>KNOB Class</strong> that we can use to create command line options. We'll analyse the example implementations in detail.</p></ul><pre class=language-cpp data-lang=cpp style=background:#0f1419;color:#bfbab0><code class=language-cpp data-lang=cpp><span>
</span><span style=font-style:italic;color:#5c6773>//profiler.cpp
</span><span>
</span><span style=color:#ff7733>#include </span><span style=color:#c2d94c>"pin.H"
</span><span>
</span><span>KNOB<</span><span style=color:#ff7733>bool</span><span>> </span><span style=color:#ffb454>ProfileCalls</span><span>(</span><span style=color:#f29718>KNOB_MODE_WRITEONCE</span><span style=color:#bfbab0cc>,</span><span style=color:#c2d94c>"pintool"</span><span style=color:#bfbab0cc>,</span><span style=color:#c2d94c>"c"</span><span style=color:#bfbab0cc>,</span><span style=color:#c2d94c>"o"</span><span style=color:#bfbab0cc>,</span><span style=color:#c2d94c>"Profile function calls"</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>KNOB<</span><span style=color:#ff7733>bool</span><span>> </span><span style=color:#ffb454>ProfileSyscalls</span><span>(</span><span style=color:#f29718>KNOB_MODE_WRITEONCE</span><span style=color:#bfbab0cc>,</span><span style=color:#c2d94c>"pintool"</span><span style=color:#bfbab0cc>,</span><span style=color:#c2d94c>"s"</span><span style=color:#bfbab0cc>,</span><span style=color:#c2d94c>"o"</span><span style=color:#bfbab0cc>,</span><span style=color:#c2d94c>"Profile syscalls"</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>
</span></code></pre><p>Here there are two options of the type <strong>KNOB<bool> called <strong>ProfileCalls</strong> and <strong>ProfileSyscalls</strong>. <blockquote><p>The options use mode <strong>KNOB_MODE_WRITEONCE</strong> because they're Boolean Flags that are set only <strong>once</strong> when we supply the flag.</blockquote> <ul><li>We can enable <strong>ProfileCalls</strong> flag by passing <code>-c</code> flag.<li>We can enable <strong>ProfileSyscalls</strong> flag by passing <code>-s</code> flag.</ul> <p>Both flags are by default set to <strong>false</strong> , means if we dont pass the command-line flags, they remain disabled throughout the course of the execution of our pintool.</p> <p>We can also create other types of command line args , like <em>str</em> or <em>int</em>.</p> <pre class=language-cpp data-lang=cpp style=background:#0f1419;color:#bfbab0><code class=language-cpp data-lang=cpp><span style=font-style:italic;color:#5c6773>//continuation of profiler.cpp
</span><span>
</span><span>std</span><span style=color:#f29668>::</span><span>map&LTADDRINT</span><span style=color:#bfbab0cc>,</span><span>std</span><span style=color:#f29668>::</span><span>map&LTADDRINT</span><span style=color:#bfbab0cc>,</span><span style=color:#ff7733>unsigned long</span><span>> > cflows</span><span style=color:#bfbab0cc>;
</span><span>std</span><span style=color:#f29668>::</span><span>map&LTADDRINT</span><span style=color:#bfbab0cc>,</span><span>std</span><span style=color:#f29668>::</span><span>map&LTADDRINT</span><span style=color:#bfbab0cc>,</span><span style=color:#ff7733>unsigned long</span><span>> > calls</span><span style=color:#bfbab0cc>;
</span><span>std</span><span style=color:#f29668>::</span><span>map&LTADDRINT</span><span style=color:#bfbab0cc>,</span><span style=color:#ff7733>unsigned long</span><span>> syscalls</span><span style=color:#bfbab0cc>;
</span><span>std</span><span style=color:#f29668>::</span><span>map&LTADDRINT</span><span style=color:#bfbab0cc>,</span><span>std</span><span style=color:#f29668>::</span><span>string> funcnames</span><span style=color:#bfbab0cc>;
</span><span>
</span></code></pre> <p>Our profiler uses multiple <strong>std::map</strong> data structures and counters to keep track of program's runtime statistics.</p> <p>The <strong>cflows</strong> and <strong>calls</strong> data structures map addresses of control flow targets to another map that inturn tracks the address of the control flow instructions that invoke each target and counts how often that control transfer was taken.</p> <p>The <strong>syscall</strong> map simply tracks how often a syscall was triggered and the <strong>funcnames</strong> maps function address to symbolic names.</p> <pre class=language-cpp data-lang=cpp style=background:#0f1419;color:#bfbab0><code class=language-cpp data-lang=cpp><span>
</span><span style=font-style:italic;color:#5c6773>//continuation of profiler.cpp
</span><span>
</span><span style=color:#ff7733>unsigned long</span><span> insn_count </span><span style=color:#f29668>= </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;
</span><span style=color:#ff7733>unsigned long</span><span> cflow_count </span><span style=color:#f29668>= </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;
</span><span style=color:#ff7733>unsigned long</span><span> call_count </span><span style=color:#f29668>= </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;
</span><span style=color:#ff7733>unsigned long</span><span> syscall_count </span><span style=color:#f29668>= </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;
</span></code></pre> <p>These counters are self-explanatory.</p> <h3 id=initializing-pin>Initializing PIN</h3> <p>Like normal programs written in C/C++ , pintools also start with a <code>main</code> function.</p> <pre class=language-cpp data-lang=cpp style=background:#0f1419;color:#bfbab0><code class=language-cpp data-lang=cpp><span style=font-style:italic;color:#5c6773>//continuation of profiler.cpp
</span><span>
</span><span style=color:#ff7733>int </span><span style=color:#ffb454>main</span><span>(</span><span style=color:#ff7733>int </span><span style=color:#f29718>argc</span><span style=color:#bfbab0cc>,</span><span style=color:#ff7733>char </span><span style=color:#f29668>*</span><span style=color:#f29718>argv</span><span>[])
</span><span>{
</span><span>    </span><span style=color:#ffb454>PIN_InitSymbols</span><span>()</span><span style=color:#bfbab0cc>; </span><span style=font-style:italic;color:#5c6773>//Reads the application's symbol tables
</span><span>    </span><span style=color:#ff7733>if</span><span>(</span><span style=color:#ffb454>PIN_Init</span><span>(argc</span><span style=color:#bfbab0cc>,</span><span>argv)) </span><span style=font-style:italic;color:#5c6773>//Initializes PIN , has all cmd-line options as well as PINtool's options while creating knobs
</span><span>    {
</span><span>        </span><span style=color:#ffb454>print_Usage</span><span>()</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#ff7733>return </span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>;
</span><span>    }
</span><span>}
</span></code></pre> <p>So we have setup PIN , and now the most important part of initializing pintool is <strong>registering the instrumentation routines</strong> that are responsible for instrumenting the application.</p> <p>The profiler registers three instrumentation routines.</p> <ol><li><strong>parse_funcsyms</strong> , instruments at image(executable) granularity.<li><strong>instrument_trace</strong> and <strong>instrument_insn</strong> instrument at <strong>trace</strong> and <strong>instruction</strong> granularity.</ol> <p>To register these with PIN , we call <strong>IMG_AddInstrument Function</strong>, <strong>TRACE_AddInstrument Function</strong> and <strong>INS_AddInstrument Function</strong> .</p> <p>The 3 instrumentation routines that we've seen just now take an <em>IMG</em> ,a <em>TRACE</em> and an <em>INS</em> object as their first parameter, respectively depending on their type. As a second arg , these functions take a <code>void *</code> which allow us to specify when we register the instrumentation routines using <code>*_AddInstrument Function</code>.</p> <h3 id=syscall-entry-function>SYSCALL ENTRY FUNCTION</h3> <p>Pin also allows us to call functions before or after every syscall , in the same way we register instrumentation callbacks.</p> <blockquote><p>Note that we can't specify callbacks for some syscalls but we can differentiate between syscalls inside the callback function.</blockquote> <p>The Profiler uses <strong>Pin_AddSyscallEntryFunction</strong> to register a function named <strong>log_syscall</strong> that's called whenever a syscall is entered.</p> <blockquote><p>To register a callback that triggers when a syscall exits , we can use <strong>PIN_AddSyscallExitFunction</strong> instead.</blockquote> <p>Note that profile registers the callback only if the value of <strong>ProfileSyscall</strong> is true.</p> <h3 id=fini-function>FINI FUNCTION</h3> <p>The final callback that the profile registers is a <em>fini function</em> , which is called when the app exits or when the PIN is detached from it.</p> <p>This function is responsible for printing profiling results. {: .notice}</p> <pre class=language-cpp data-lang=cpp style=background:#0f1419;color:#bfbab0><code class=language-cpp data-lang=cpp><span style=font-style:italic;color:#5c6773>//continuation of profiler.cpp
</span><span>
</span><span>    </span><span style=color:#ffb454>IMG_AddInstrumentFunction</span><span>(parse_funcsyms</span><span style=color:#bfbab0cc>,</span><span style=color:#f29718>NULL</span><span>)</span><span style=color:#bfbab0cc>; </span><span style=font-style:italic;color:#5c6773>//second arg is passed as NULL here
</span><span>    </span><span style=color:#ffb454>TRACE_AddInstrumentFunction</span><span>(instrument_trace</span><span style=color:#bfbab0cc>,</span><span style=color:#f29718>NULL</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ffb454>INS_AddInstrumentFunction</span><span>(instrument_insn</span><span style=color:#bfbab0cc>,</span><span style=color:#f29718>NULL</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>
</span><span>    </span><span style=color:#ff7733>if</span><span>(ProfileSyscalls</span><span style=color:#f29668>.</span><span style=color:#ffb454>value</span><span>())
</span><span>    {
</span><span>        </span><span style=color:#ffb454>PIN_AddSyscallEntryFunction</span><span>(log_syscall</span><span style=color:#bfbab0cc>,</span><span style=color:#f29718>NULL</span><span>)</span><span style=color:#bfbab0cc>; </span><span style=font-style:italic;color:#5c6773>//logging syscalls
</span><span>    }
</span><span>    </span><span style=color:#ffb454>PIN_AddFiniFunction</span><span>(print_results</span><span style=color:#bfbab0cc>,</span><span style=color:#f29718>NULL</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>
</span><span>    </span><span style=color:#ffb454>PIN_StartProgram</span><span>()</span><span style=color:#bfbab0cc>; </span><span style=font-style:italic;color:#5c6773>//Never returns and hence return 0 is never reached
</span><span>
</span><span>    </span><span style=color:#ff7733>return </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;
</span><span>
</span></code></pre> <p>Let's look at a few details of Parsing Function Symbols.</p> <h2 id=parsing-function-symbols>PARSING FUNCTION SYMBOLS</h2> <p>We recall that <strong>parse_funcsyms</strong> is an <strong>image-granularity</strong> instrumentation routine. Such routines are called when a new image(binary/library) is loaded, allowing us to instrument the image as a whole.</p> <p>This also lets us loop over all the functions in the image and add analysis routines before or after a function.</p> <blockquote><p>Note that function instrumentation is reliabel only if the binary contains <strong>symbolic info</strong>. Also note that <strong>after-function</strong> instrumentation doesn't work with some optimizations , such as <strong>tail calls</strong>.</blockquote> <pre class=language-cpp data-lang=cpp style=background:#0f1419;color:#bfbab0><code class=language-cpp data-lang=cpp><span style=font-style:italic;color:#5c6773>//continuation of profiler.cpp
</span><span>
</span><span style=color:#ff7733>static void </span><span style=color:#ffb454>parse_funcsyms</span><span>(IMG </span><span style=color:#f29718>img</span><span style=color:#bfbab0cc>,</span><span style=color:#ff7733>void </span><span style=color:#f29668>*</span><span style=color:#f29718>v</span><span>)
</span><span>{
</span><span>    </span><span style=color:#ff7733>if</span><span>(</span><span style=color:#f29668>!</span><span style=color:#ffb454>IMG_valid</span><span>(img)) </span><span style=font-style:italic;color:#5c6773>//checks for a valid image
</span><span>        </span><span style=color:#ff7733>return</span><span style=color:#bfbab0cc>;
</span><span>}
</span><span>
</span></code></pre> <p>If the image is valid , <strong>parse_funcsyms</strong> loops over all <strong>SEC</strong> objects in the image , which represent all sections.</p> <pre class=language-cpp data-lang=cpp style=background:#0f1419;color:#bfbab0><code class=language-cpp data-lang=cpp><span>    </span><span style=color:#ff7733>for</span><span>(SEC sec </span><span style=color:#f29668>= </span><span style=color:#ffb454>IMG_SecHead</span><span>(img)</span><span style=color:#bfbab0cc>; </span><span style=color:#ffb454>SEC_Valid</span><span>(sec)</span><span style=color:#bfbab0cc>;</span><span> sec </span><span style=color:#f29668>= </span><span style=color:#ffb454>SEC_Next</span><span>(sec))
</span><span>    {
</span><span>        </span><span style=color:#ff7733>for</span><span>(RTN rtn </span><span style=color:#f29668>= </span><span style=color:#ffb454>SEC_RtnHead</span><span>(sec) </span><span style=color:#bfbab0cc>; </span><span style=color:#ffb454>RTN_Valid</span><span>(rtn)</span><span style=color:#bfbab0cc>;</span><span> rtn </span><span style=color:#f29668>= </span><span style=color:#ffb454>RTN_Next</span><span>(rtn))
</span><span>        {
</span><span>            funcnames[</span><span style=color:#ffb454>RTN_Address</span><span>(rtn)] </span><span style=color:#f29668>= </span><span style=color:#ffb454>RTN_Name</span><span>(rtn)</span><span style=color:#bfbab0cc>;
</span><span>        }
</span><span>    }
</span><span>
</span></code></pre> <p>For each section , <em>parse_funcsyms</em> iterates over all the functions (represented by <strong>RTN</strong> objects , meaning <strong>Routine</strong> ) and maps each function's address in the <em>funcnames</em> map to the symbolic name of the function , if the function name is unknown then it returns an empty string.</p> <p><strong>REMARK</strong> -> This kind of function based instrumentation is rendered useless in stripped binaries which are devoid of any symbols.</p> <h2 id=implementing-basic-block-instrumentation>IMPLEMENTING BASIC BLOCK INSTRUMENTATION</h2> <p>Unfortunately , we can't implement basic blocks in PIN API directly , ie , there's no <strong>BBL_AddInstrumentFunction</strong>.</p> <p>To instrument basic blocks , you have to add a <strong>Trace level</strong> instrumentation routine and then loop over all basic blocks in trace , instrumenting each one.</p> <pre class=language-cpp data-lang=cpp style=background:#0f1419;color:#bfbab0><code class=language-cpp data-lang=cpp><span style=color:#ff7733>static void </span><span style=color:#ffb454>instrument_trace</span><span>(TRACE </span><span style=color:#f29718>trace </span><span style=color:#bfbab0cc>, </span><span style=color:#ff7733>void </span><span style=color:#f29668>*</span><span style=color:#f29718>v</span><span>)
</span><span>{
</span><span>    IMG img </span><span style=color:#f29668>= </span><span style=color:#ffb454>IMG_FindByAddress</span><span>(</span><span style=color:#ffb454>TRACE_Address</span><span>(trace))</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>if</span><span>(</span><span style=color:#f29668>!</span><span style=color:#ffb454>IMG_Valid</span><span>(img) </span><span style=color:#f29668>|| !</span><span style=color:#ffb454>IMG_IsMainExecutable</span><span>(img))
</span><span>        </span><span style=color:#ff7733>return</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>for</span><span>(BBL bb </span><span style=color:#f29668>= </span><span style=color:#ffb454>TRACE_BblHead</span><span>(trace) </span><span style=color:#bfbab0cc>; </span><span style=color:#ffb454>BBL_valid</span><span>(bb) </span><span style=color:#bfbab0cc>;</span><span> bb </span><span style=color:#f29668>= </span><span style=color:#ffb454>BBL_Next</span><span>(bb))
</span><span>    {
</span><span>        </span><span style=color:#ffb454>instrument_bb</span><span>(bb)</span><span style=color:#bfbab0cc>;
</span><span>    }
</span><span>}
</span><span>
</span></code></pre> <ol><li>First , the <strong>instrument_trace</strong> calls <strong>IMG_FindByAddress</strong> to find the IMG that the trace is part of.<li>If the trace is valid and part of main application , <strong>instrument_trace</strong> loops over all Basic Blocks , <strong>BBL</strong> objects in the trace.<li>For each <strong>BBL</strong> it calls <strong>instrument_bb</strong> which performs the instrumentation of each basic block.<li>To instrument a given BBL , <strong>instrument_bb</strong> calls <strong>BBL_InsertCall</strong> which is PIN's API function to instrument a basic block with an <strong>analysis routine callback</strong>.</ol> <p><strong>BBL_InsertCall</strong> takes 3 args , one <strong>bb</strong> , two an <strong>insertion point</strong> and third a <strong>function pointer</strong> to the analysis routine we wish to add.</p> <pre class=language-cpp data-lang=cpp style=background:#0f1419;color:#bfbab0><code class=language-cpp data-lang=cpp><span style=color:#ff7733>static void </span><span style=color:#ffb454>instrument_bb</span><span>(BBL </span><span style=color:#f29718>bb</span><span>)
</span><span>{
</span><span>    </span><span style=color:#ffb454>BBL_InsertCall</span><span>(bb</span><span style=color:#bfbab0cc>,</span><span>IPOINT_ANYWHERE</span><span style=color:#bfbab0cc>,</span><span>(AFUNPTR)count_bb_insns</span><span style=color:#bfbab0cc>,</span><span>IARG_UINT32</span><span style=color:#bfbab0cc>,</span><span style=color:#ffb454>BBL_NumIns</span><span>(bb)</span><span style=color:#bfbab0cc>,</span><span>IARG_END)</span><span style=color:#bfbab0cc>;
</span><span>}
</span><span>
</span></code></pre> <p>In this case , the insertion point is <strong>IPOINT_ANYWHERE</strong> because it doesn't matter at what point in the basic block the instruction counter is updated.</p> <p>Here's a table which has information of a few insertion points.</p> <table><thead><tr><th style=text-align:left><strong>Insertion Point</strong><th style=text-align:center><strong>Analysis CallBack</strong><th style=text-align:right><strong>Validity</strong><tbody><tr><td style=text-align:left>IPOINT_BEFORE<td style=text-align:center>Before Instrumented object<td style=text-align:right>Always valid<tr><td style=text-align:left>IPOINT_AFTER<td style=text-align:center>On fallthrough edge of a branch or a regular instruction<td style=text-align:right>If INS_HasFallThrough is true<tr><td style=text-align:left>IPOINT_ANYWHERE<td style=text-align:center>Anywhere in instrumented object<td style=text-align:right>For Trace or BBL<tr><td style=text-align:left>IPOINT_TAKEN_BRANCH<td style=text-align:center>On taken edge of a branch<td style=text-align:right>If INS_isBranchOrCall is true<tr><td style=text-align:left>=====<td style=text-align:center><td style=text-align:right><tr><td style=text-align:left>{: rules="groups"}<td style=text-align:center><td style=text-align:right></table> <p>In our implementation , there's an option argument of type <strong>IAARG_UINT32</strong> with value <strong>BBL_NumIns</strong> and <strong>IARG_END</strong> is to specofy the end of args.</p> <h2 id=instrumenting-control-flow-instructions>INSTRUMENTING CONTROL FLOW INSTRUCTIONS</h2> <p>The profiler can count the <em>number of control flow transfers</em> and optionally , the number of calls.</p> <p>Our <strong>instrument_insn</strong> takes <strong>INS</strong> ins and a void* as args.</p> <ol><li>Initially , it checks whether our <strong>INS</strong> object is a control-flow instruction or not.</ol> <pre class=language-cpp data-lang=cpp style=background:#0f1419;color:#bfbab0><code class=language-cpp data-lang=cpp><span style=color:#ff7733>static void </span><span style=color:#ffb454>instrument_insn</span><span>(INS </span><span style=color:#f29718>ins </span><span style=color:#bfbab0cc>, </span><span style=color:#ff7733>void </span><span style=color:#f29668>*</span><span style=color:#f29718>v</span><span>)
</span><span>{
</span><span>    </span><span style=color:#ff7733>if</span><span>(</span><span style=color:#f29668>!</span><span style=color:#ffb454>INS_isBranchOrCall</span><span>(ins))
</span><span>        </span><span style=color:#ff7733>return</span><span style=color:#bfbab0cc>;
</span><span>}
</span><span>
</span></code></pre> <ol start=2><li>After that , it checks whether the instruction is a part of the main application or not.</ol> <pre class=language-cpp data-lang=cpp style=background:#0f1419;color:#bfbab0><code class=language-cpp data-lang=cpp><span>    IMG img </span><span style=color:#f29668>= </span><span style=color:#ffb454>IMG_FindByAddress</span><span>(</span><span style=color:#ffb454>INS_Address</span><span>(ins))</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>if</span><span>(</span><span style=color:#f29668>!</span><span style=color:#ffb454>IMG_Valid</span><span>(img) </span><span style=color:#f29668>|| !</span><span style=color:#ffb454>IMG_isMainExecutable</span><span>(img))
</span><span>        </span><span style=color:#ff7733>return</span><span style=color:#bfbab0cc>;
</span><span>
</span><span>    </span><span style=color:#ffb454>INS_InsertPredicatedCall</span><span>(ins</span><span style=color:#bfbab0cc>,</span><span>IPOINT_TAKEN_BRANCH</span><span style=color:#bfbab0cc>,</span><span>(AFUNPTR)count_cflow</span><span style=color:#bfbab0cc>,</span><span>IARG_INST_PTR</span><span style=color:#bfbab0cc>,</span><span>IARG_BRANCH_TARGET_ADDR</span><span style=color:#bfbab0cc>,</span><span>IARG_END)</span><span style=color:#bfbab0cc>;
</span><span>
</span></code></pre> <h2 id=instrumenting-the-taken-edge>INSTRUMENTING THE TAKEN EDGE</h2> <p>To record control transfers and calls , <strong>instrument_insn</strong> inserts three different analysis callbacks.</p> <ol><li>First, it uses <strong>INS_InsertPredicatedCall</strong> to insert a callback on the instruction's taken edge.<li>The inserted analysis callback to <em>count_cflow</em> increments the control-flow counter in case the branch is taken and records the source and target addresses of control flow.</ol> <p>Note that <strong>instrument_insn</strong> uses <strong>INS_InsertPredicatedCall</strong> to insert a callback instead of <strong>INS_InsertCall</strong>.Analysis callbacks inserted with <strong>INS_PredicatedCall</strong> only if the condition holds and the instruction is executed. {: .notice}</p> <blockquote><p>In contrast to the above fact , callbacks inserted with <strong>INS_InsertCall</strong> are called even if the repeat condition doesn't hold , leading to an <em>overestimation</em> of instruction count.</blockquote> <h2 id=instrumenting-the-fall-through-edge>INSTRUMENTING THE FALL THROUGH EDGE</h2> <p>The profiler should record control transfer regardless of the <strong>branch direction</strong>.</p> <blockquote><p>Note that some instructions such as <strong>unconditional jumps</strong> have <strong>no</strong> fallthrough edges meaning that we have to explicitly check <strong>INS_HasFallthrough</strong> before we try to instrument an instruction's fallthrough edge.</blockquote> <blockquote><p>Also Note that According to Pin's definition , <strong>non-control flow instructions</strong> that just continue to the next instruction <strong>do have a fallthrough edge</strong>.</blockquote> <pre class=language-cpp data-lang=cpp style=background:#0f1419;color:#bfbab0><code class=language-cpp data-lang=cpp><span>
</span><span style=font-style:italic;color:#5c6773>// Previously we just declared INS_PredicatedCall , now let's define it
</span><span>
</span><span>    </span><span style=color:#ff7733>if</span><span>(</span><span style=color:#ffb454>INS_HasFallThrough</span><span>(ins))
</span><span>    {
</span><span>        </span><span style=color:#ffb454>INS_PredicatedCall</span><span>(IPOINT_AFTER</span><span style=color:#bfbab0cc>,</span><span>(AFUNPTR)count_cflow</span><span style=color:#bfbab0cc>,</span><span>IARG_INST_PTR</span><span style=color:#bfbab0cc>,</span><span>IARG_FALLTHROUGH_ADDR</span><span style=color:#bfbab0cc>,</span><span>IARG_END)</span><span style=color:#bfbab0cc>;
</span><span>    }
</span><span>
</span></code></pre> <p>As we can see from the above code , if the given instruction turns out to have a Fallthrough Edge , <strong>instrument_insn</strong> inserts an analysis callback to <strong>count_cflow</strong> on that edge as it did for taken edge also. The only difference is that this new callback uses insertion point <strong>IPOINT_AFTER</strong> and passes <strong>fallthrough's address</strong> as the target address to record</p> <h2 id=instrumenting-calls>INSTRUMENTING CALLS</h2> <p>The profiler keeps a separate counter and mapping to track called functions so that we can see which functions are more better for our application.</p> <p>Recall that we have to pass <strong>-c</strong> flag to enable tracking called functions. {: .notice}</p> <p>To instrument calls , our <strong>instrument_insn</strong> uses <strong>INS_IsCall</strong> to separate calls from other instructions.</p> <pre class=language-cpp data-lang=cpp style=background:#0f1419;color:#bfbab0><code class=language-cpp data-lang=cpp><span>
</span><span style=color:#ff7733>if</span><span>(</span><span style=color:#ffb454>INS_IsCall</span><span>(ins))
</span><span>{
</span><span>    </span><span style=color:#ff7733>if</span><span>(ProfileCalls</span><span style=color:#f29668>.</span><span style=color:#ffb454>Value</span><span>())
</span><span>    {
</span><span>        </span><span style=color:#ffb454>INS_InsertCall</span><span>(ins</span><span style=color:#bfbab0cc>,</span><span>IPOINT_BEFORE</span><span style=color:#bfbab0cc>,</span><span>(AFUNPTR)count_call</span><span style=color:#bfbab0cc>,</span><span>IARG_INST_PTR</span><span style=color:#bfbab0cc>,</span><span>IARG</span><span style=color:#bfbab0cc>,</span><span>BRANCH_TARGET_ADDR</span><span style=color:#bfbab0cc>,</span><span>IARG_END)</span><span style=color:#bfbab0cc>;
</span><span>
</span><span>    }
</span><span>}
</span><span>
</span></code></pre> <p>If the instruction is a call , then the profiler inserts an analysis callback before the call instruction at <strong>IPOINT_BEFORE</strong> to an analysis routine called <strong>count_call</strong> passing in the call's source , ie the Instruction Pointer and target address.</p> <p>Here it's safe to use <strong>INS_InsertCall</strong> instead of <strong>INS_InsertPredicatedCall</strong> because there are no call instructions with built-in conditionals.</p> <p>Now let's see a few analysis routines that we've used so far.</p> <pre class=language-cpp data-lang=cpp style=background:#0f1419;color:#bfbab0><code class=language-cpp data-lang=cpp><span>
</span><span style=color:#ff7733>static void </span><span style=color:#ffb454>count_bb_insn</span><span>(UNINT32 </span><span style=color:#f29718>n</span><span>)
</span><span>{
</span><span>    insn_count </span><span style=color:#f29668>+=</span><span> n
</span><span>}
</span><span>
</span><span style=color:#ff7733>static void </span><span style=color:#ffb454>count_cflow</span><span>(ADDRINT </span><span style=color:#f29718>ip</span><span style=color:#bfbab0cc>,</span><span> ADDRINT </span><span style=color:#f29718>target</span><span>)
</span><span>{
</span><span>    cflows[target][ip]</span><span style=color:#f29668>++</span><span style=color:#bfbab0cc>;
</span><span>    cflow_count</span><span style=color:#f29668>++</span><span style=color:#bfbab0cc>;
</span><span>}
</span><span>
</span><span style=color:#ff7733>static void </span><span style=color:#ffb454>count_call</span><span>(ADDRINT </span><span style=color:#f29718>ip</span><span style=color:#bfbab0cc>,</span><span> ADDRINT </span><span style=color:#f29718>target</span><span>)
</span><span>{
</span><span>    calls[target][ip]</span><span style=color:#f29668>++</span><span style=color:#bfbab0cc>;
</span><span>    call_count</span><span style=color:#f29668>++</span><span style=color:#bfbab0cc>;
</span><span>}
</span><span>
</span><span style=color:#ff7733>static void </span><span style=color:#ffb454>log_syscall</span><span>(THREADID </span><span style=color:#f29718>tid </span><span style=color:#bfbab0cc>,</span><span> CONTEXT </span><span style=color:#f29668>*</span><span style=color:#f29718>ctx</span><span style=color:#bfbab0cc>,</span><span> SYSCALL_STANDARD </span><span style=color:#f29718>std </span><span style=color:#bfbab0cc>, </span><span style=font-style:italic;color:#39bae6>VOID </span><span style=color:#f29668>*</span><span style=color:#f29718>v</span><span>)
</span><span>{
</span><span>    syscalls[</span><span style=color:#ffb454>PIN_GetSyscallNumber</span><span>(ctx</span><span style=color:#bfbab0cc>,</span><span>std)]</span><span style=color:#f29668>++</span><span style=color:#bfbab0cc>;
</span><span>    syscall_count</span><span style=color:#f29668>++</span><span style=color:#bfbab0cc>;
</span><span>}
</span></code></pre> <p>The function <strong>log_syscall</strong> is not a regular analysis routine but a callback for syscall entry events.</p> <p>In PIN , syscall handlers take 4 args , a <strong>THREADID</strong> identifying the thread that made the syscall ; a <code>CONTEXT *</code> containing things like syscall number , arguments , and return value (only for syscall exit handlers) ; a <strong>SYSCALL_STANDARD</strong> argument that verifies the syscall's calling convention and finally the <code>void*</code> which allows us to pass user-defined data structure.</p> <p>Recall that purpose of <strong>log_syscall</strong> is to record how often each syscall is called.</p> <p>It calls <strong>Get_SyscallNumber</strong> to get the current syscall's number and records a hit for that syscall in <em>syscalls</em> map.</p> 