<!doctype html><html class="dark light"><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         UAF - HackTheBox 2020
        
    </title><meta content="UAF - HackTheBox 2020" property=og:title><link href=https://pwnverse.github.io/fonts.css rel=stylesheet><script>(function(){var a=document.createElement('script');a.setAttribute('src','/js/imamu.js');a.setAttribute('data-website-id','74344cd8-1e87-4c38-8acd-f96049b8f07e');a.setAttribute('data-host-url','https:&#x2F;&#x2F;analytics.eu.umami.is');document.body.appendChild(a)})()</script><script async data-host-url=https://analytics.eu.umami.is data-website-id=74344cd8-1e87-4c38-8acd-f96049b8f07e src=/js/imamu.js></script><script async data-goatcounter=https://Cyb0rG.goatcounter.com/count src=https://pwnverse.github.io/js/count.js></script><noscript><img src="https://Cyb0rG.goatcounter.com//count?p=/posts/uaf/&t=UAF - HackTheBox 2020"></noscript><link title="Cyb0rG's Home" href=https://pwnverse.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://pwnverse.github.io/theme/light.css rel=stylesheet><link href=https://pwnverse.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><link href=https://pwnverse.github.io/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://pwnverse.github.io>Cyb0rG's Home</a><div class=socials><a class=social href=https://twitter.com/_Cyb0rG rel=me> <img alt=twitter src=/social_icons/twitter.svg> </a><a class=social href=https://github.com/PwnVerse/ rel=me> <img alt=github src=/social_icons/github.svg> </a></div></div><nav><a href=/posts style=margin-left:.7em>/posts</a><a href=/projects style=margin-left:.7em>/projects</a><a href=/about style=margin-left:.7em>/about</a> | <a href=javascript:void(0) id=dark-mode-toggle onclick=toggleTheme()> <img id=sun-icon src=/feather/sun.svg style=filter:invert(1)> <img id=moon-icon src=/feather/moon.svg> </a><script src=https://pwnverse.github.io/js/themetoggle.js></script></nav></header><main><article><div class=title><div class=page-header>UAF - HackTheBox 2020<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2020-11-22</time></div></div><section class=body><h1 id=tl-dr>tl;dr</h1><ul><li>Leak <code>libc</code> and <code>heap</code> addresses , use the edit option to get allocation at tcache structure.<li>Create fake tcache entry for <code>stdout</code> file structure , get allocation at <code>stdout</code> to leak <code>stack</code> from <code>environ</code>.<li>Free and allocate tcache structure to re-edit , this time get allocation at <code>return address</code> on stack , finally execute mprotect rop chain and <code>orw</code> shellcode.</ul><p><strong>Challenge Points:</strong> 1000 <strong>Solves:</strong> 5<p>HackTheBox had really interesting heap challenges and this is one of the challenges we solved during the CTF.<h2 id=initial-analysis>Initial analysis</h2><p>We had been provided with the binary as well as the source code for a standard CTF-style menu driven program. The libc provided inside the docker was <code>2.32</code>.<pre class=language-sh data-lang=sh style=background:#0f1419;color:#bfbab0><code class=language-sh data-lang=sh><span style=color:#ffb454>CANARY</span><span>    : ENABLED
</span><span style=color:#ffb454>FORTIFY</span><span>   : disabled
</span><span style=color:#ffb454>NX</span><span>        : ENABLED
</span><span style=color:#ffb454>PIE</span><span>       : ENABLED
</span><span style=color:#ffb454>RELRO</span><span>     : FULL
</span></code></pre><h2 id=reversing>Reversing</h2><p>Since source code was provided , it was pretty self explanatory. The program implements <code>seccomp rules</code> and the following system calls have been allowed.<pre class=language-sh data-lang=sh style=background:#0f1419;color:#bfbab0><code class=language-sh data-lang=sh><span>	</span><span style=color:#ffb454>Allow</span><span>(brk)</span><span style=color:#ffb454>,
</span><span>	</span><span style=color:#ffb454>Allow</span><span>(mmap)</span><span style=color:#ffb454>,
</span><span>	</span><span style=color:#ffb454>Allow</span><span>(exit_group)</span><span style=color:#ffb454>,
</span><span>	</span><span style=color:#ffb454>Allow</span><span>(mmap)</span><span style=color:#ffb454>,
</span><span>	</span><span style=color:#ffb454>Allow</span><span>(munmap)</span><span style=color:#ffb454>,
</span><span>	</span><span style=color:#ffb454>Allow</span><span>(read)</span><span style=color:#ffb454>,
</span><span>	</span><span style=color:#ffb454>Allow</span><span>(write)</span><span style=color:#ffb454>,
</span><span>	</span><span style=color:#ffb454>Allow</span><span>(getdents)</span><span style=color:#ffb454>,
</span><span>	</span><span style=color:#ffb454>Allow</span><span>(mprotect)</span><span style=color:#ffb454>,
</span><span>	</span><span style=color:#ffb454>Allow</span><span>(open)</span><span style=color:#ffb454>,
</span><span>	</span><span style=color:#ffb454>Allow</span><span>(sendfile)</span><span style=color:#ffb454>,
</span></code></pre><p>The program implements the structure of a custom chunk provided by malloc.<pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=color:#ff7733>typedef struct</span><span> _chunk {
</span><span>	</span><span style=font-style:italic;color:#39bae6>uint32_t</span><span> size</span><span style=color:#bfbab0cc>;
</span><span>	</span><span style=color:#ff7733>void </span><span style=color:#f29668>*</span><span> ptr</span><span style=color:#bfbab0cc>;
</span><span>	</span><span style=color:#ff7733>bool</span><span> in_use</span><span style=color:#bfbab0cc>;
</span><span>} </span><span style=color:#59c2ff>chunk</span><span style=color:#bfbab0cc>;
</span></code></pre><p>It has <code>size</code>, a void* <code>ptr</code> and a flag <code>in_use</code>.<p><code>Alloc</code> :<ul><li>The maximum size of an allocated chunk should not exceed <code>0x400</code>.<li>After allocation, chunk's first field <code>ptr</code> is set to NULL , data is read into the memory.<li>Subsequently , the <code>in_use</code> flag is set to true and size is set.</ul><p><code>Delete</code> :<ul><li><code>idx</code> should be less than or equal to <code>0x10</code>.<li>This option prints data and then frees the memory without nulling out the pointer.<li>Finally , it sets the <code>in_use</code> flag to false.</ul><p><code>Edit</code> :<ul><li>Lets us edit a byte of a chunk at an index only once.</ul><h2 id=bug>Bug</h2><p>The <code>Delete</code> option has a simple Use after free.<h2 id=getting-heap-and-libc-leak>Getting heap and libc leak</h2><p>We can only view a chunk we are about to free. To get libc leak , we can simply fill a tcache bin corresponding to small bin size. Then, after we have a chunk in the unsorted bin ,we can add a small chunk , which will be allocated from the unsorted bin , free it to get libc.<p>For heap , its actually a little more complicated than we expected. Since libc is 2.32 , the <code>fd</code> pointer of a tcache chunk will be encoded with this algorithm.<p><img src="https://lh5.googleusercontent.com/proxy/6WVq2hd0LuqnQLN0K6xkaYaZ1DtYaQPW9I-svrS95apQQI_sw16cnQ6iNaKfYRN_cZr1kV947ps16uBDo6VB0GhjzytXx3yJgPg7zE93jBZ8Tp3xQfhdYEgXJn3-s4vH=w1200-h630-p-k-no-nu" alt> {: .image-pull-right}<p>We can't use tcache bins to leak heap as in tcache , the first 8 bytes will be encoded , and the next 8 bytes which stores the address of <code>tcache structure</code>. Moreover , the malloc algorithm clears the address of <code>tcache structure</code> and hence , we can't leak heap.So , our only option is to use unsorted bins as malloc does not clear addresses of unsorted bin. If we send two chunks into unsorted bin , the fd and bk pointers will be libc and heap. So , there's a chance we can leak libc here.<p>When we allocate memory from unsorted bin , for some reason , it replaces the heap pointer with a libc pointer thus taking us further away from leaking heap.<p>During the CTF , we were stuck here for sometime. Soon enough , we realized that if we can merge <strong>two unsorted bin</strong> chunks , the fd and bk of the chunk being merged are not cleared. Hence , in the next allocation ,we can actually overlap with our heap leak.<pre class=language-sh data-lang=sh style=background:#0f1419;color:#bfbab0><code class=language-sh data-lang=sh><span style=color:#ffb454>0x561195df27b0:</span><span>	0x0000000000000000	0x0000000000000141 -</span><span style=color:#f29668>></span><span> consolidated unsorted bin ( 0xa0 + 0xa0 )
</span><span style=color:#ffb454>0x561195df27c0:</span><span>	0x0000561195df26f0	0x00007f0be6ddec00
</span><span style=color:#ffb454>0x561195df27d0:</span><span>	0x0000000000000000	0x0000000000000000
</span><span style=color:#ffb454>0x561195df27e0:</span><span>	0x0000000000000000	0x0000000000000000
</span><span style=color:#ffb454>0x561195df27f0:</span><span>	0x0000000000000000	0x0000000000000000
</span><span style=color:#ffb454>0x561195df2800:</span><span>	0x0000000000000000	0x0000000000000000
</span><span style=color:#ffb454>0x561195df2810:</span><span>	0x0000000000000000	0x0000000000000000
</span><span style=color:#ffb454>0x561195df2820:</span><span>	0x0000000000000000	0x0000000000000000
</span><span style=color:#ffb454>0x561195df2830:</span><span>	0x0000000000000000	0x0000000000000000
</span><span style=color:#ffb454>0x561195df2840:</span><span>	0x0000000000000000	0x0000000000000000
</span><span style=color:#ffb454>0x561195df2850:</span><span>	0x0000000000000000	0x00000000000000a1 -</span><span style=color:#f29668>></span><span> Overlapping chunk that is merged with the above chunk
</span><span style=color:#ffb454>0x561195df2860:</span><span>	0x0000561195df26f0	0x00007f0be6ddec00 -</span><span style=color:#f29668>></span><span> fd (heap) </span><span style=color:#ffb454>and</span><span> bk are not cleared
</span><span style=color:#ffb454>0x561195df2870:</span><span>	0x0000000000000000	0x0000000000000000
</span><span style=color:#ffb454>0x561195df2880:</span><span>	0x0000000000000000	0x0000000000000000
</span><span style=color:#ffb454>0x561195df2890:</span><span>	0x0000000000000000	0x0000000000000000
</span><span style=color:#ffb454>0x561195df28a0:</span><span>	0x0000000000000000	0x0000000000000000
</span><span style=color:#ffb454>0x561195df28b0:</span><span>	0x0000000000000000	0x0000000000000000
</span><span style=color:#ffb454>0x561195df28c0:</span><span>	0x0000000000000000	0x0000000000000000
</span><span style=color:#ffb454>0x561195df28d0:</span><span>	0x0000000000000000	0x0000000000000000
</span><span style=color:#ffb454>0x561195df28e0:</span><span>	0x0000000000000000	0x0000000000000000
</span><span style=color:#ffb454>0x561195df28f0:</span><span>	0x0000000000000140	0x0000000000000020
</span></code></pre><p>Now , we can fill memory until the heap address , and then free it to leak heap.<h2 id=allocation-at-stack>Allocation at stack</h2><p>We have libc and heap leaks ,now what? The next step is to use our vulnerable edit function to edit a byte of forward pointer. We could choose to target malloc or free hook , but remember , there's seccomp enabled and I honestly was too lazy to find gadgets for following a jump oriented programming approach with complex rop.<p>So again , we were stuck at this point. One idea which we were pondering upon was to get allocation at stdout <code>vtables</code> [vtables are writeable in libc 2.32 surprisingly]. We could get code execution multiple times , but we could not chain any stack pivoting gadgets since registers were being corrupted before getting code execution multiple times. Hence, we had to drop this idea as well.<p>Finally , we planned to get allocation at tcache structure. We can do something like this.<ul><li>Edit the last byte of a free chunk to point to a fake chunk whose <code>fd</code> pointer is encoded with the address of tcache structure.</ul><p>This way , we had leveraged arbitrary write using a single byte edit. But , we needed more than one arbitrary writes , the answer to which was the tcache structure.<p>We could free the tcache structure and reallocate it to edit it as many times as we want.<p>Our idea was to get allocation the return address of the <code>alloc</code> function so that we can rop and mprotect heap to get shellcode execution. For that , what we can do is -<ul><li>Edit tcache count and the corresponding tcache entry to that count with the address of <code>stdout</code> file structure.<li>Get allocation at <code>stdout</code> , the plan is to leak stack from <code>environ</code>.<li>Overwrite <code>stdout->flags</code> with <code>0xfbad3887</code><li>Overwrite <code>IO_read_ptr</code> , <code>IO_read_end</code> and <code>_IO_read_base</code> with NULL.<li>Overwrite <code>IO_write_base</code> with address of <code>environ</code>.<li>Overwrite <code>IO_write_end</code> with address of <code>environ+0x10</code>.</ul><p>Detailed information about arbitrary memory read from file structures <a href=https://gsec.hitb.org/materials/sg2018/D1%20-%20FILE%20Structures%20-%20Another%20Binary%20Exploitation%20Technique%20-%20An-Jie%20Yang.pdf>here</a><p>Awesome , we have stack leak , now , re-edit tcache structure to get allocation at return address. Make sure the stack address should be 16-byte aligned else malloc will abort due to alignment issues.<h2 id=shellcode-and-flag>Shellcode and flag</h2><p>All set and done , we get allocation at return address. From here , it's a fairly simple problem to mprotect <code>heap</code> and give an <code>orw</code> shellcode. But wait , there is one problem.<p>Looking at the <code>Dockerfile</code> we saw , this line<pre class=language-sh data-lang=sh style=background:#0f1419;color:#bfbab0><code class=language-sh data-lang=sh><span style=color:#ffb454>CMD</span><span> mv /home/ctf/flag.txt /home/ctf/</span><span style=color:#ff7733>[</span><span>REDACTED</span><span style=color:#ff7733>]</span><span>_flag.txt
</span></code></pre><p>So , the flag file name is unknown now. Looking at seccomp filters , we see that , we have <code>getdents</code> syscall allowed which is exactly what we need now.<p>Getdents allows us to list all files in a directory. We will choose <code>.</code> directory and get all file names.<p>The shellcode for getdents is<pre class=language-sh data-lang=sh style=background:#0f1419;color:#bfbab0><code class=language-sh data-lang=sh><span>
</span><span>        </span><span style=color:#ffb454>/*</span><span> open(</span><span style=color:#c2d94c>'.'</span><span>) </span><span style=color:#ffb454>*/
</span><span>        </span><span style=color:#ffb454>mov</span><span> rdi, 0x2e
</span><span>        </span><span style=color:#ffb454>push</span><span> 0
</span><span>        </span><span style=color:#ffb454>push</span><span> rdi
</span><span>        </span><span style=color:#ffb454>push</span><span> rsp
</span><span>        </span><span style=color:#ffb454>pop</span><span> rdi
</span><span>        </span><span style=color:#ffb454>mov</span><span> rax, 2
</span><span>        </span><span style=color:#ffb454>xor</span><span> rsi, rsi
</span><span>        </span><span style=color:#ffb454>cdq
</span><span>        </span><span style=color:#ffb454>syscall
</span><span>
</span><span>        </span><span style=color:#ffb454>/*</span><span> getdents </span><span style=color:#f29668>*</span><span>/
</span><span>        </span><span style=color:#ffb454>mov</span><span> rdi, rax
</span><span>        </span><span style=color:#ffb454>mov</span><span> rax, 0x4e
</span><span>        </span><span style=color:#ffb454>lea</span><span> rsi, </span><span style=color:#ff7733>[</span><span>rbp</span><span style=color:#ff7733>-</span><span>0x70</span><span style=color:#ff7733>]
</span><span>        </span><span style=color:#ffb454>cdq
</span><span>        </span><span style=color:#ffb454>mov</span><span> dh, 0x10
</span><span>        </span><span style=color:#ffb454>syscall
</span><span>
</span><span>        </span><span style=color:#ffb454>/*</span><span> write </span><span style=color:#f29668>*</span><span>/
</span><span>        </span><span style=color:#ffb454>mov</span><span> rdi, 1
</span><span>        </span><span style=color:#ffb454>lea</span><span> rsi, </span><span style=color:#ff7733>[</span><span>rbp</span><span style=color:#ff7733>-</span><span>0x70</span><span style=color:#ff7733>]
</span><span>        </span><span style=color:#ffb454>mov</span><span> rdx, rax
</span><span>        </span><span style=color:#ffb454>mov</span><span> rax, 1
</span><span>        </span><span style=color:#ffb454>syscall
</span></code></pre><p>Once , we get the flag file name , we can do a simple <code>orw</code> shellcode.<p>PS : In the end , we found out that flag file name is <code>/home/ctf/flag.txt</code> itself , which was pretty frustrating :/<h2 id=conclusion>Conclusion</h2><p>There could have been many possibilities to mprotect and execute shellcode , we choose the good old stack to get it done. All in all , it was a really good challenge.<p><a href=https://gist.github.com/PwnVerse/2f1fea428f3850d72d2ac9ac3d9c2c78>Here</a> is the exploit script.</section></article></main></div>