<!doctype html><html class="dark light"><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Understanding the Userfaultfd Syscall
        
    </title><meta content="Understanding the Userfaultfd Syscall" property=og:title><link href=https://pwnverse.github.io/fonts.css rel=stylesheet><script>(function(){var a=document.createElement('script');a.setAttribute('src','/js/imamu.js');a.setAttribute('data-website-id','74344cd8-1e87-4c38-8acd-f96049b8f07e');a.setAttribute('data-host-url','https:&#x2F;&#x2F;analytics.eu.umami.is');document.body.appendChild(a)})()</script><script async data-host-url=https://analytics.eu.umami.is data-website-id=74344cd8-1e87-4c38-8acd-f96049b8f07e src=/js/imamu.js></script><script async data-goatcounter=https://Cyb0rG.goatcounter.com/count src=https://pwnverse.github.io/js/count.js></script><noscript><img src="https://Cyb0rG.goatcounter.com//count?p=/posts/userfaultfd/&t=Understanding the Userfaultfd Syscall"></noscript><link title="Cyb0rG's Home" href=https://pwnverse.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://pwnverse.github.io/theme/light.css rel=stylesheet><link href=https://pwnverse.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><link href=https://pwnverse.github.io/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://pwnverse.github.io>Cyb0rG's Home</a><div class=socials><a class=social href=https://twitter.com/_Cyb0rG rel=me> <img alt=twitter src=/social_icons/twitter.svg> </a><a class=social href=https://github.com/PwnVerse/ rel=me> <img alt=github src=/social_icons/github.svg> </a></div></div><nav><a href=/posts style=margin-left:.7em>/posts</a><a href=/projects style=margin-left:.7em>/projects</a><a href=/about style=margin-left:.7em>/about</a> | <a href=javascript:void(0) id=dark-mode-toggle onclick=toggleTheme()> <img id=sun-icon src=/feather/sun.svg style=filter:invert(1)> <img id=moon-icon src=/feather/moon.svg> </a><script src=https://pwnverse.github.io/js/themetoggle.js></script></nav></header><main><article><div class=title><div class=page-header>Understanding the Userfaultfd Syscall<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2020-08-04</time></div></div><section class=body><p>Linux provides a bunch of syscalls among which only a few are known and used often.Most of the syscalls we use are always wrapped around cheesy glibc wrappers (functions). But there are a few syscalls which have no such glibc wrappers and one of the most interesting of them is the <strong>Userfaultfd</strong> syscall.<p>Hence , I dedicate this post to kind of clear my own bemusement of this wonderful syscall.<p>Ok so the very first thing that comes to the mind of any layperson.<h2 id=what-is-userfaultfd-syscall>WHAT IS USERFAULTFD SYSCALL</h2><p>I would like to shamelessly site the definition of userfaultfd from its very own <strong>man</strong> page (trust me, there's no better definition available other than this one :).<pre class=language-sh data-lang=sh style=background:#0f1419;color:#bfbab0><code class=language-sh data-lang=sh><span style=color:#ffb454>userfaultfd</span><span>()  creates a new userfaultfd object that can be used for delegation of page-fault handling
</span><span>to a user-space application, and returns a file descriptor that refers to the  new  object.
</span><span>
</span></code></pre><p>Hey wait , what is a page fault?<p>In the event of an attempt of accessing a page which is no longer available in main memory , a kernel interrupt called <strong>page fault</strong> is setup which kind of gets back the page you were trying to access back into main memory from the secondary memory. {: .notice}<p>So basically , we use userfaultfd to keep track of page faults , which is kernel level stuff.<p>But how does userfaultfd do that??<h2 id=how-does-userfaultfd-do-what-it-does>How Does USERFAULTFD do what it does?</h2><p>So once we create the userfaultfd object , we have to configure it using <strong>ioctl</strong>.<p>Once the userfaultfd object is configured , the application can use <strong>read</strong> to recieve userfaultfd notifications. The read can be blocking or non-blocking depending on the flags.<h3 id=some-intricate-internals>Some intricate internals</h3><p>The userfaultfd is designed to allow a separate thread in a multithreaded program to perform user-space paging for other threads in the process.<p>When a page that is registered with userfaultfd gives a page fault , the faulting thread is put to sleep and an event is generated that can be read via the userfaultfd file descriptor.<p>The fault handling thread reads events from this file descriptor and services them using the operations described in <strong>ioctl_userfaultfd</strong>. Also , while servicing the page fault events , the fault-handling thread can trigger a wake-up for the sleeping thread.<h3 id=an-ambiguity>An Ambiguity</h3><p>It is possible for the faulting threads and the faul-handling threads to run in context of different processes.<p>In this case, these threads may belong to different programs, and the program that executes the faulting threads will not necessarily cooperate with the thread that handles page faults. {: .notice}<p>In such a non-cooperative mode , the process that monitors userfaultfd and handles page faults needs to be aware of the changes in the virtual memory layout of the faulting process to avoid memory corruption.<h3 id=what-all-information-userfaultfd-notifies-us>What all information Userfaultfd notifies us</h3><ol><li><p>Notify the faulting threads about changes in virtual memory layout of the faulting process.</p><li><p>If faulting thread invokes <strong>fork()</strong> , the userfaultfd objects maybe duplicated in the child process and we get notified about the uffd objects in the child processes using <strong>UFFD_EVENT_FORK</strong>. This allows user-space paging in the child process.</p></ol><h3 id=synchronizing-userfaultfd>SYNCHRONIZING Userfaultfd</h3><p>The userfaultfd manager should carefully synchronize calls to <strong>UFFDIO_COPY</strong> with the processing of events.The noncooperative events asynchronously resume execution once the userfaultfd reads into its file descriptor.<h3 id=handshake-between-kernel-and-userspace>Handshake Between Kernel and Userspace</h3><ol><li><p>After the creation of userfaultfd object , the application must enable it using the <strong>UFFDIO_API_ioctl</strong> operation. This operation allows handshake between kernel and userspace to determine the API version and supported features.</p><li><p>Then , the application registers memory address ranges using <strong>UFFDIO_REGISTER\ ioctl</strong>.</p><li><p>After successful completion of <strong>UFFDIO_REGISTER</strong> , a page fault occuring in the requested memory range , will be forwarded by the kernel to the user-space application. The application can then use the <strong>UFFDIO_COPY</strong> or <strong>UFFDIO_ZEROPAGE ioctl</strong> operations to resolve page faults.</p></ol><h3 id=using-userfaultfd-only-to-detect-pagefaults>Using Userfaultfd only to detect pagefaults</h3><p>If the application sets <strong>UFFD_FEATURE_SIGBUS</strong> using <strong>UFFDIO_API ioctl</strong> , a <strong>SIGBUS</strong> is delivered instead of any other notifications about page faults.<h3 id=reading-from-the-userfaultfd-structure>Reading from the userfaultfd structure</h3><p>Each read from the userfaultfd fd returns one or more <strong>uffd_msg</strong> structs, each of which describe a page-fault event or an even required for the non-cooperative userfaultfd usage.<pre class=language-c data-lang=c style=background:#0f1419;color:#bfbab0><code class=language-c data-lang=c><span>         </span><span style=color:#ff7733>struct </span><span style=color:#59c2ff>uffd_msg </span><span>{
</span><span>               __u8  event</span><span style=color:#bfbab0cc>;            </span><span style=font-style:italic;color:#5c6773>/* Type of event */
</span><span>               </span><span style=color:#f29668>...
</span><span>               </span><span style=color:#ff7733>union </span><span>{
</span><span>                   </span><span style=color:#ff7733>struct </span><span>{
</span><span>                       __u64 flags</span><span style=color:#bfbab0cc>;    </span><span style=font-style:italic;color:#5c6773>/* Flags describing fault */
</span><span>                       __u64 address</span><span style=color:#bfbab0cc>;  </span><span style=font-style:italic;color:#5c6773>/* Faulting address */
</span><span>                   } pagefault</span><span style=color:#bfbab0cc>;
</span><span>
</span><span>                   </span><span style=color:#ff7733>struct </span><span>{            </span><span style=font-style:italic;color:#5c6773>/* Since Linux 4.11 */
</span><span>                       __u32 ufd</span><span style=color:#bfbab0cc>;      </span><span style=font-style:italic;color:#5c6773>/* Userfault file descriptor
</span><span style=font-style:italic;color:#5c6773>                                          of the child process */
</span><span>                   } fork</span><span style=color:#bfbab0cc>;
</span><span>
</span><span>                   </span><span style=color:#ff7733>struct </span><span>{            </span><span style=font-style:italic;color:#5c6773>/* Since Linux 4.11 */
</span><span>                       __u64 from</span><span style=color:#bfbab0cc>;     </span><span style=font-style:italic;color:#5c6773>/* Old address of remapped area */
</span><span>                       __u64 to</span><span style=color:#bfbab0cc>;       </span><span style=font-style:italic;color:#5c6773>/* New address of remapped area */
</span><span>                       __u64 len</span><span style=color:#bfbab0cc>;      </span><span style=font-style:italic;color:#5c6773>/* Original mapping length */
</span><span>                   } remap</span><span style=color:#bfbab0cc>;
</span><span>
</span><span>                   </span><span style=color:#ff7733>struct </span><span>{            </span><span style=font-style:italic;color:#5c6773>/* Since Linux 4.11 */
</span><span>                       __u64 start</span><span style=color:#bfbab0cc>;    </span><span style=font-style:italic;color:#5c6773>/* Start address of removed area */
</span><span>                       __u64 end</span><span style=color:#bfbab0cc>;      </span><span style=font-style:italic;color:#5c6773>/* End address of removed area */
</span><span>                   } remove</span><span style=color:#bfbab0cc>;
</span><span>                   </span><span style=color:#f29668>...
</span><span>               } arg</span><span style=color:#bfbab0cc>;
</span><span>
</span><span>               </span><span style=font-style:italic;color:#5c6773>/* Padding fields omitted */
</span><span>           } __packed</span><span style=color:#bfbab0cc>;
</span><span>
</span><span>
</span><span>
</span></code></pre><p>If multiple events are available and the supplied buffer is large enough , read returns as many events as the size of the buffer. Else if the buffer is smaller than the size of the uffd_msg struct , then it returns error.<p>Each of the fields of the structure have been described in detail in the man page of userfaultfd.</section></article></main></div>